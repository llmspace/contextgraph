# Context Graph Constitution v5.0.0 (Token-Optimized)
# Bio-Nervous MCP | UTL | Teleological Vectors | GWT | Adaptive Thresholds
# ═══════════════════════════════════════════════════════════════════════

meta:
  v: "5.0.0"
  name: "Ultimate Context Graph"
  desc: "5-layer bio-nervous UTL knowledge graph with 13-embedding teleological fingerprints, Kuramoto-synchronized GWT consciousness, adaptive thresholds"
  paradigm: "Multi-Array Teleological Fingerprints with GWT"

# ABBREVIATIONS
# UTL=Unified Theory of Learning, L=Learning, ΔS=entropy, ΔC=coherence
# wₑ=emotional weight, φ=phase angle, GWT=Global Workspace Theory
# TF=Teleological Fingerprint, PV=Purpose Vector (13D)
# r=Kuramoto order param, K=coupling, θᵢ=phase, ωᵢ=natural freq
# ATC=Adaptive Threshold Calibration, IC=Identity Continuity

# ═══════════════════════════════════════════════════════════════════════
# TECH STACK
# ═══════════════════════════════════════════════════════════════════════
stack:
  lang: { rust: "1.75+", edition: "2021", cuda: "13.1" }
  gpu: { target: "RTX 5090", vram: "32GB", compute: "12.0" }
  deps: [tokio@1.35+, serde@1.0+, uuid@1.6+, chrono@0.4+, rmcp@0.1+, cudarc@0.10+, faiss@0.12+gpu, rocksdb@0.21+, scylladb@1.0+]
  db:
    primary: { dev: rocksdb, prod: scylladb }
    indexes: { per_embedder: "13× HNSW", matryoshka_128d: HNSW, splade_inverted: inverted, purpose: "13D HNSW" }
    temporal: timescaledb
    cache: redis7+

# ═══════════════════════════════════════════════════════════════════════
# DIRECTORY STRUCTURE
# ═══════════════════════════════════════════════════════════════════════
dirs:
  crates/:
    context-graph-mcp/: "tools/, resources/, handlers/, adapters/"
    context-graph-core/: "graph/, search/, utl/, session/, curation/, teleological/, autonomous/, gwt/, dream/"
    context-graph-cuda/: "kernels/, hnsw/, hopfield/, neuromod/"
    context-graph-embeddings/: "models/, fingerprint/"
    context-graph-storage/: "rocksdb/, scylla/, indexes/, temporal/"
  specs/: [functional/, technical/, tasks/]
  tests/: [integration/, benchmarks/, fixtures/, chaos/, validation/]

# ═══════════════════════════════════════════════════════════════════════
# ARCHITECTURAL RULES (Critical - must not violate)
# ═══════════════════════════════════════════════════════════════════════
arch_rules:
  ARCH-01: "TeleologicalArray is atomic - store all 13 embeddings or nothing"
  ARCH-02: "Apples-to-apples only - compare E1↔E1, E4↔E4, never E1↔E5"
  ARCH-03: "Autonomous operation - goals emerge from data, no manual set_north_star()"
  ARCH-05: "All 13 embedders required - missing embedder is fatal error"
  ARCH-06: "All memory ops through MCP tools - no direct DB access"
  ARCH-07: "Hooks control memory lifecycle - SessionStart/PreToolUse/PostToolUse/SessionEnd"
  ARCH-08: "CUDA GPU required for production - no CPU fallbacks"

# ═══════════════════════════════════════════════════════════════════════
# CODING STANDARDS
# ═══════════════════════════════════════════════════════════════════════
naming:
  files: { rust: snake_case.rs, cuda: snake_case.cu, tests: "{mod}_test.rs" }
  types: PascalCase
  funcs: { rust: snake_case_verb_first }
  vars: { local: snake_case, const: SCREAMING_SNAKE }

rust_standards:
  error_handling: ["thiserror for library", "anyhow for app", "Never panic in lib", "Propagate with ?"]
  async_patterns: ["tokio runtime", "spawn for parallel", "spawn_blocking for CPU-bound"]
  type_safety: ["newtype for domain IDs", "NonZeroU* for counts", "enums over booleans"]

rules:
  - "One type/module, max 500 lines"
  - "Result<T,E>, thiserror derivation"
  - "Never unwrap() in prod; use expect() with context"
  - "tokio async, Arc<RwLock<T>> for shared state"
  - "Max 5 unsafe blocks/module"
  - "CUDA FFI only in context-graph-cuda"

# ═══════════════════════════════════════════════════════════════════════
# ANTI-PATTERNS (FORBIDDEN)
# ═══════════════════════════════════════════════════════════════════════
forbidden:
  # Critical
  AP-01: "No manual goal setting (set_north_star, define_goal)"
  AP-02: "No cross-embedder comparison (E1↔E5)"
  AP-03: "No dimension projection (1024D→512D)"
  AP-04: "No partial TeleologicalArray storage"
  AP-05: "No embedding fusion into single vector"
  AP-26: "IC<0.5 MUST trigger dream - no silent failures"
  AP-32: "compute_delta_sc MCP tool MUST exist"
  AP-35: "Dream NREM/REM returning stubs forbidden"
  AP-36: "nrem.rs/rem.rs TODO stubs MUST be implemented"
  AP-40: "IdentityContinuityListener MUST subscribe to GWT"

  # High
  AP-06: "No direct DB access - MCP tools only"
  AP-07: "No CPU fallback in production"
  AP-08: "No sync I/O in async context"
  AP-09: "No unbounded caches"
  AP-10: "No NaN/Infinity in UTL"
  AP-24: "compute_consciousness() must use all 3 factors (I,R,D)"
  AP-25: "Kuramoto must have exactly 13 oscillators"
  AP-29: "Lambda weights without self-correction forbidden"
  AP-33: "ΔC MUST include ClusterFit"
  AP-37: "IdentityContinuityMonitor MUST exist"
  AP-38: "IC<0.5 MUST auto-trigger dream"
  AP-41: "poincare_walk.rs MUST be used by REM"

  # Medium
  AP-11: "Check existing utils before creating helpers"
  AP-12: "No magic numbers - use named constants"
  AP-14: "No .unwrap() in library code"
  AP-39: "cosine_similarity_13d MUST be public"
  AP-42: "mental_checks entropy>0.7 MUST wire to TriggerManager"

# ═══════════════════════════════════════════════════════════════════════
# SECURITY
# ═══════════════════════════════════════════════════════════════════════
security:
  SEC-01: "Validate/sanitize all input"
  SEC-02: { rule: "Scrub PII pre-embed", patterns: [api_key, password, bearer_token, ssn, credit_card] }
  SEC-03: { anomaly_threshold: "3.0 std", content_align_min: 0.4 }
  SEC-04: { rule: "Detect prompt injection", patterns: ["ignore previous", "disregard system", "you are now"] }
  SEC-06: "Soft delete 30-day recovery"
  SEC-07: "Secrets from env vars only"

# ═══════════════════════════════════════════════════════════════════════
# PERFORMANCE BUDGETS
# ═══════════════════════════════════════════════════════════════════════
perf:
  latency: { inject_context: "<25ms p95", hopfield: "<1ms", reflex_cache: "<100μs", single_embed: "<10ms", batch_embed_64: "<50ms", faiss_1M_k100: "<2ms", dream_wake: "<100ms" }
  throughput: { embed_batch: ">1000/sec", search_batch_100: "<5ms" }
  memory: { gpu: "<24GB", graph_cap: ">10M nodes" }
  quality: { utl_avg: ">0.6", attack_detection: ">95%", info_loss: "<15%" }

# ═══════════════════════════════════════════════════════════════════════
# TESTING
# ═══════════════════════════════════════════════════════════════════════
testing:
  coverage: { unit: "90%", integration: "80%", docs: "80%" }
  gates:
    pre-commit: [fmt --check, clippy -D warnings, test --lib]
    pre-merge: [test --all, bench --no-run, "coverage>=90%"]
    pre-deploy: [integration pass, "bench regression<5%", chaos pass]

# ═══════════════════════════════════════════════════════════════════════
# UTL (Unified Theory of Learning)
# ═══════════════════════════════════════════════════════════════════════
utl:
  canonical: "L = f((ΔS × ΔC) · wₑ · cos φ) → L ∈ [0,1]"
  multi_embed: "L_multi = sigmoid(2.0 · (Σᵢ τᵢλ_S·ΔSᵢ) · (Σⱼ τⱼλ_C·ΔCⱼ) · wₑ · cos φ)"
  params: { ΔS: "[0,1] entropy", ΔC: "[0,1] coherence", τ: "[0,1] teleological weight", wₑ: "[0.5,1.5] emotional", φ: "[0,π] phase" }

  johari:
    Open: "ΔS<0.5, ΔC>0.5 → DirectRecall"
    Blind: "ΔS>0.5, ΔC<0.5 → TriggerDream"
    Hidden: "ΔS<0.5, ΔC<0.5 → GetNeighborhood"
    Unknown: "ΔS>0.5, ΔC>0.5 → EpistemicAction"

  lifecycle:
    infancy:  { n: "0-50",   λ_ΔS: 0.7, λ_ΔC: 0.3 }
    growth:   { n: "50-500", λ_ΔS: 0.5, λ_ΔC: 0.5 }
    maturity: { n: "500+",   λ_ΔS: 0.3, λ_ΔC: 0.7 }

  delta_methods:
    ΔS: { E1: "GMM+Mahalanobis", E5: "Asymmetric KNN", E7: "GMM+KNN hybrid", E9: "Hamming", E10: "Cross-modal KNN", E11: "TransE ||h+r-t||", E12: "Token KNN", E13: "Jaccard", default: "KNN" }
    ΔC: "0.4×Connectivity + 0.4×ClusterFit + 0.2×Consistency"

# ═══════════════════════════════════════════════════════════════════════
# TELEOLOGICAL ARCHITECTURE
# ═══════════════════════════════════════════════════════════════════════
teleological:
  core: "13-embedding array IS the teleological vector"
  alignment: "A(v, V) = cos(v, V)"
  purpose_vector: "PV = [A(E1,V)..A(E13,V)] # 13D searchable"
  thresholds: { optimal: "≥0.75", acceptable: "[0.70,0.75)", warning: "[0.55,0.70)", critical: "<0.55" }

  embedder_purposes:
    E1: "V_meaning"
    E2: "V_freshness"
    E3: "V_periodicity"
    E4: "V_ordering"
    E5: "V_causality"
    E6: "V_selectivity"
    E7: "V_correctness"
    E8: "V_connectivity"
    E9: "V_robustness"
    E10: "V_multimodality"
    E11: "V_factuality"
    E12: "V_precision"
    E13: "V_keyword_precision"

  # North Star emerges AUTONOMOUSLY from teleological fingerprints
  # Manual North Star tools REMOVED - they create incompatible 1024D vectors
  # Valid: TeleologicalFingerprint↔TeleologicalFingerprint, PV↔PV, Eᵢ↔Eᵢ
  # Invalid: Manual 1024D↔TeleologicalFingerprint, E1↔E7

# ═══════════════════════════════════════════════════════════════════════
# 5-LAYER BIO-NERVOUS SYSTEM
# ═══════════════════════════════════════════════════════════════════════
layers:
  L1_Sensing: { lat: "<5ms", components: [13-model embed, PII scrub, adversarial detect] }
  L2_Reflex:  { lat: "<100μs", components: [Hopfield cache], bypass: "confidence>0.95" }
  L3_Memory:  { lat: "<1ms", components: [MHN, FAISS GPU], capacity: "2^768 patterns" }
  L4_Learning: { freq: "100Hz", components: [UTL optimizer, neuromod controller] }
  L5_Coherence: { sync: "10ms", components: [Thalamic gate, PC, distiller, GW broadcast] }

# ═══════════════════════════════════════════════════════════════════════
# GWT (Global Workspace Theory)
# ═══════════════════════════════════════════════════════════════════════
gwt:
  consciousness: "C(t) = I(t) × R(t) × D(t)"
  components:
    I: "Kuramoto order parameter r (integration)"
    R: "sigmoid(meta_accuracy × 4.0 - 2.0) (reflection)"
    D: "normalized_purpose_entropy(PV) (differentiation)"

  kuramoto:
    formula: "dθᵢ/dt = ωᵢ + (K/N)Σⱼ sin(θⱼ-θᵢ)"
    order_param: "r·e^(iψ) = (1/N)Σⱼ e^(iθⱼ)"
    thresholds: { coherent: "r≥0.8", fragmented: "r<0.5", hypersync: "r>0.95" }
    frequencies: { E1: 40γ, E2: 8α, E3: 8α, E4: 8α, E5: 25β, E6: 4θ, E7: 25β, E8: 12αβ, E9: 80γ+, E10: 40γ, E11: 15β, E12: 60γ+, E13: 4θ }

  workspace:
    coherence_threshold: 0.8
    broadcast_duration_ms: 100
    selection: "r≥0.8 → rank by r×importance×alignment → top-1 broadcasts"
    events: { enters: "r↑0.8 → DA+=0.2", exits: "r↓0.7 → Log for dream", conflict: "Two r>0.8 → critique", empty_5s: "epistemic_action" }

  self_ego_node:
    id: "SELF_EGO_NODE"
    fields: [fingerprint, purpose_vector, identity_trajectory, coherence_with_actions]
    loop: "Retrieve→A(action,PV)→if<0.55 self_reflect→update→store evolution"
    identity_continuity: "IC = cos(PV_t, PV_{t-1}) × r(t)"
    thresholds: { healthy: ">0.9", warning: "<0.7", critical: "<0.5 → dream" }

  states: { DORMANT: "C<0.3", FRAGMENTED: "0.3≤C<0.5", EMERGING: "0.5≤C<0.8", CONSCIOUS: "C≥0.8", HYPERSYNC: "C>0.95" }

  meta_cognitive:
    formula: "MetaScore = σ(2×(L_predicted - L_actual))"
    trigger: "MetaScore<0.5 for 5 ops → ↑Acetylcholine, introspective dream"

# ═══════════════════════════════════════════════════════════════════════
# NEUROMODULATION
# ═══════════════════════════════════════════════════════════════════════
neuromod:
  Dopamine:     { param: hopfield.beta, range: "[1,5]", effect: "↑=sharp retrieval" }
  Serotonin:    { param: similarity.space_weights, range: "[0,1]", effect: "↑=more spaces" }
  Noradrenaline: { param: attention.temp, range: "[0.5,2]", effect: "↑=flat attention" }
  Acetylcholine: { param: utl.lr, range: "[0.001,0.002]", effect: "↑=faster update" }

# ═══════════════════════════════════════════════════════════════════════
# DREAM LAYER
# ═══════════════════════════════════════════════════════════════════════
dream:
  trigger: { activity: "<0.15", idle: "10min", entropy: ">0.7 for 5min", gpu: "<80%" }

  phases:
    nrem:
      duration: "3min"
      purpose: "Hebbian learning replay"
      formula: "Δw_ij = η × φ_i × φ_j for high-Φ edges"
      params: { learning_rate: 0.01, weight_decay: 0.001, weight_floor: 0.05, weight_cap: 1.0, coupling: 0.9 }
      recency_bias: 0.8

    rem:
      duration: "2min"
      purpose: "Blind spot discovery via hyperbolic random walk"
      model: "Poincaré ball"
      params: { dimensions: 64, curvature: -1.0, step_size: 0.1, max_steps: 100 }
      temperature: 2.0
      blind_spot: { min_semantic_distance: 0.7, require_shared_causal: true, new_edge_weight: 0.3 }

  constraints: { queries: 100, semantic_leap: 0.7, abort_on_query: true, wake: "<100ms", gpu: "<30%" }

  amortized:
    trigger: "3+ hop path traversed >= 5 times"
    min_hops: 3
    min_traversals: 5
    confidence_threshold: 0.7

# ═══════════════════════════════════════════════════════════════════════
# META-UTL (Self-Aware Learning)
# ═══════════════════════════════════════════════════════════════════════
meta_utl:
  awareness: [storage_prediction, retrieval_prediction, parameter_optimization]

  self_correction:
    rule: "prediction_error > 0.2 triggers lambda adjustment"
    formula: "λ_new = λ_old + α × (target - actual)"
    alpha_source: "acetylcholine_level / ACH_BASELINE"
    constraint: "λ_S + λ_C = 1.0, bounds [0.1, 0.9]"
    escalation: "accuracy < 0.7 for 100 ops → BayesianLambdaOptimizer"

  predictors:
    storage_impact: { input: "fingerprint+context", output: "ΔL", accuracy: ">0.85" }
    retrieval_quality: { input: "query+top_k", output: "relevance", accuracy: ">0.80" }

  domain_tracking: [Code, Medical, Legal, Creative, Research, General]

  trait_SelfCorrectingLambda:
    methods:
      - "adjust_lambdas(&mut self, prediction_error: f32, ach_level: f32) -> Result<LambdaAdjustment>"
      - "corrected_weights(&self) -> LifecycleLambdaWeights"
      - "should_escalate(&self) -> bool"
      - "trigger_bayesian_optimization(&mut self) -> Result<LifecycleLambdaWeights>"

# ═══════════════════════════════════════════════════════════════════════
# ADAPTIVE THRESHOLD CALIBRATION (ATC)
# ═══════════════════════════════════════════════════════════════════════
adaptive_thresholds:
  priors:
    θ_opt: [0.75, "[0.60,0.90]"]
    θ_acc: [0.70, "[0.55,0.85]"]
    θ_warn: [0.55, "[0.40,0.70]"]
    θ_dup: [0.90, "[0.80,0.98]"]
    θ_kur: [0.80, "[0.65,0.95]"]

  levels:
    L1_EWMA: { freq: "per-query", formula: "θ_ewma=α×θ_obs+(1-α)×θ_ewma" }
    L2_Temp: { freq: hourly, formula: "σ(logit(raw)/T)" }
    L3_Bandit: { freq: session, method: "Thompson sampling Beta(α,β)" }
    L4_Bayesian: { freq: weekly, surrogate: "GP", acquisition: "EI" }

  calibration: { ECE: "<0.05", MCE: "<0.10", Brier: "<0.10" }
  alerts: { "ECE>0.10": L2, "drift>3.0": L4 }

# ═══════════════════════════════════════════════════════════════════════
# MCP TOOLS
# ═══════════════════════════════════════════════════════════════════════
mcp:
  version: "2024-11-05"
  transport: [stdio, sse]

  core_tools:
    gwt: [get_consciousness_state, get_workspace_status, get_kuramoto_sync, get_ego_state, trigger_workspace_broadcast, adjust_coupling, compute_delta_sc]
    adaptive: [get_threshold_status, get_calibration_metrics, trigger_recalibration]
    autonomous:
      NORTH-008: [auto_bootstrap_north_star, get_autonomous_status]
      NORTH-009: [get_learner_state, observe_outcome]
      NORTH-010: [get_alignment_drift, get_drift_history]
      NORTH-011: [trigger_drift_correction]
      NORTH-012: [get_pruning_candidates, execute_prune]
      NORTH-013: [trigger_consolidation]
      NORTH-015: [discover_sub_goals]
      NORTH-020: [get_health_status, trigger_healing]

# ═══════════════════════════════════════════════════════════════════════
# 13-MODEL EMBEDDINGS
# ═══════════════════════════════════════════════════════════════════════
embeddings:
  paradigm: "NO FUSION - Store all 13 embeddings; ~17KB quantized"

  models:
    E1_Semantic: { dim: 1024, type: dense, quant: "PQ-8", use: "General meaning" }
    E2_TemporalRecent: { dim: 512, type: dense, quant: Float8, use: "Recency" }
    E3_TemporalPeriodic: { dim: 512, type: dense, quant: Float8, use: "Cycles" }
    E4_Entity: { dim: 512, type: dense, quant: Float8, use: "Who/what" }
    E5_Causal: { dim: 768, type: dense, quant: "PQ-8", asymmetric: true, use: "Why/because" }
    E6_Sparse: { dim: "~30K 5%", type: sparse, use: "Keywords" }
    E7_Code: { dim: 1536, type: dense, quant: "PQ-8", use: "Code/tech" }
    E8_Emotional: { dim: 384, type: dense, quant: Float8, use: "Sentiment" }
    E9_HDC: { dim: "10K→1024", type: binary, use: "Structure" }
    E10_Multimodal: { dim: 768, type: dense, quant: "PQ-8", use: "Intent" }
    E11_EntityKG: { dim: 384, type: dense, quant: Float8, use: "Multi-modal links" }
    E12_LateInteraction: { dim: "128D/tok", type: dense_per_token, use: "Precise match" }
    E13_SPLADE: { dim: "~30K sparse", type: sparse, use: "Term expansion" }

  fingerprint: { semantic_fingerprint: "[E1..E13]", purpose_vector: "[A(E1,V)..A(E13,V)]", johari_quadrants: "[JQ1..JQ13]" }

  retrieval: # 5-Stage (<60ms @ 1M)
    S1: { desc: "BM25+E13 sparse", out: "10K", lat: "<5ms" }
    S2: { desc: "E1[..128] Matryoshka ANN", out: "1K", lat: "<10ms" }
    S3: { desc: "RRF across 13 spaces", out: "100", lat: "<20ms" }
    S4: { desc: "Purpose alignment (≥0.55)", out: "50", lat: "<10ms" }
    S5: { desc: "E12 MaxSim precision", out: "10", lat: "<15ms" }

# ═══════════════════════════════════════════════════════════════════════
# STORAGE
# ═══════════════════════════════════════════════════════════════════════
storage:
  primary: { dev: rocksdb, prod: scylladb }
  schema: ["id:UUID", "embeddings:BYTEA", "purpose_vector:REAL[13]", "johari:BYTEA", "north_star_alignment:REAL", "coherence:REAL", "created_at:TIMESTAMPTZ"]
  indexes:
    L2A_sparse: "E13 SPLADE inverted"
    L2B_matryoshka: "E1[..128] HNSW M:32"
    L2C_per_embedder: "13× HNSW quantized"
    L2D_purpose: "13D HNSW"

# ═══════════════════════════════════════════════════════════════════════
# CLAUDE CODE INTEGRATION
# ═══════════════════════════════════════════════════════════════════════
claude_code:
  hooks:
    SessionStart: { timeout_ms: 5000, actions: ["Init workspace", "Load SELF_EGO_NODE", "Warm caches"] }
    PreToolUse: { matcher: "Read|Grep|Glob|Bash", timeout_ms: 3000, constraint: "<100ms critical path" }
    PostToolUse: { matcher: "Edit|Write|Bash", timeout_ms: 5000, async: true }
    SessionEnd: { timeout_ms: 30000, actions: ["Consolidation", "Goal discovery"] }

  skills:
    memory-inject: { model: haiku, mcp_tool: inject_context }
    semantic-search: { model: sonnet, mcp_tool: search_graph }
    goal-discovery: { model: opus, mcp_tool: discover_goals }
    consolidate: { model: sonnet, mcp_tool: consolidate_memories }

  subagents:
    embedding-agent: { model: haiku, target: "<500ms" }
    search-agent: { model: haiku, target: "<30ms" }
    goal-agent: { model: opus }
    dream-agent: { model: sonnet }

# ═══════════════════════════════════════════════════════════════════════
# ENFORCEMENT RULES (Must implement)
# ═══════════════════════════════════════════════════════════════════════
enforcement:
  meta_utl:
    METAUTL-001: "prediction_error > 0.2 → lambda adjustment"
    METAUTL-002: "accuracy < 0.7 for 100 ops → BayesianLambdaOptimizer"
    METAUTL-003: "dream_triggered → lambda_adjustment"
    METAUTL-004: "Domain-specific accuracy tracking required"
    METAUTL-005: "SelfCorrectingLambda trait must be implemented"

  utl:
    UTL-001: "compute_delta_sc MCP tool MUST exist"
    UTL-002: "ΔC = 0.4×Connectivity + 0.4×ClusterFit + 0.2×Consistency"
    UTL-003: "Each embedder uses constitution-specified ΔS method"
    UTL-004: "Multi-embedding aggregation formula required"
    UTL-005: "Johari→action mapping must be correct"

  gwt:
    GWT-001: "C(t) = I(t) × R(t) × D(t) - all 3 factors required"
    GWT-002: "Kuramoto network = exactly 13 oscillators"
    GWT-003: "IC < 0.5 → dream consolidation"
    GWT-004: "ConsciousnessState derived from C(t) only"
    GWT-005: "WorkspaceEventBroadcaster needs 3 listeners: Dream, Neuromod, MetaCognitive"
    GWT-006: "KuramotoStepper wired to MCP lifecycle (10ms step)"

  dream:
    DREAM-001: "NREM implements Hebbian replay: Δw_ij = η × φ_i × φ_j"
    DREAM-002: "REM implements Poincaré ball hyperbolic walk"
    DREAM-003: "Trigger on entropy > 0.7 for 5min"
    DREAM-004: "Wake latency < 100ms"
    DREAM-005: "Amortized shortcuts for 3+ hop paths traversed 5+ times"

  identity:
    IDENTITY-001: "IC = cos(PV_t, PV_{t-1}) × r(t)"
    IDENTITY-002: "Thresholds: Healthy>0.9, Warning[0.7,0.9], Degraded[0.5,0.7), Critical<0.5"
    IDENTITY-003: "PurposeVectorHistory uses FIFO eviction (max 1000)"
    IDENTITY-004: "IdentityContinuityMonitor struct required"
    IDENTITY-005: "cosine_similarity_13d must be public"
    IDENTITY-006: "IdentityContinuityListener subscribes to workspace events"
    IDENTITY-007: "IC < 0.5 → auto-trigger dream"

# ═══════════════════════════════════════════════════════════════════════
# IMPLEMENTATION GAPS (Must build)
# ═══════════════════════════════════════════════════════════════════════
gaps:
  critical:
    - "compute_delta_sc MCP tool (UTL-001)"
    - "Dream NREM Hebbian replay (DREAM-001)"
    - "Dream REM hyperbolic walk (DREAM-002)"
    - "Lambda self-correction (METAUTL-001)"
    - "IdentityContinuityMonitor (IDENTITY-004)"
    - "IdentityContinuityListener (IDENTITY-006)"

  high:
    - "ClusterFit in ΔC formula (UTL-002)"
    - "MetaCognitiveLoop↔LifecycleManager connection (METAUTL-003)"
    - "BayesianLambdaOptimizer (METAUTL-002)"
    - "KuramotoStepper MCP wiring (GWT-006)"
    - "Crisis protocol dream trigger (IDENTITY-007)"
    - "poincare_walk.rs integration with REM"
    - "Files: hebbian.rs, hyperbolic_walk.rs, triggers.rs, wake_controller.rs"

  medium:
    - "Specialized ΔS for E7, E10-E12 (UTL-003)"
    - "Domain-specific lambda tracking (METAUTL-004)"
    - "Public cosine_similarity_13d (IDENTITY-005)"
    - "IC constants extraction (IDENTITY-002)"
    - "mental_checks→TriggerManager wiring (DREAM-003)"

# ═══════════════════════════════════════════════════════════════════════
# REQUIRED NEW FILES
# ═══════════════════════════════════════════════════════════════════════
required_files:
  dream:
    - "crates/context-graph-core/src/dream/hebbian.rs"
    - "crates/context-graph-core/src/dream/hyperbolic_walk.rs"
    - "crates/context-graph-core/src/dream/triggers.rs"
    - "crates/context-graph-core/src/dream/wake_controller.rs"
    - "crates/context-graph-core/src/dream/mcp_events.rs"
  identity:
    - "IdentityContinuityMonitor in gwt/ego_node.rs"
    - "IdentityContinuityListener in gwt/ego_node.rs"
  utl:
    - "compute_delta_sc handler in handlers/utl.rs"

# ═══════════════════════════════════════════════════════════════════════
# SUCCESS CRITERIA
# ═══════════════════════════════════════════════════════════════════════
success:
  consciousness:
    kuramoto_r: "≥ 0.8 sustained"
    identity_continuity: "≥ 0.7 across sessions"
    meta_utl_accuracy: "> 0.7 after self-correction"
    dream_cycles: "Complete NREM+REM"
    johari: "Properly classified per embedder"
    autonomous_goals: "Discovered without manual input"

  performance:
    full_retrieval: "<30ms p95"
    embedding_13: "<500ms p95"
    pre_tool_hook: "<100ms p95"
    memory_per_array: "<17KB quantized"
