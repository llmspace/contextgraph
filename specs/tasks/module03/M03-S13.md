# Task Specification: M03-S13

```xml
<task_spec id="M03-S13" version="1.0">
<metadata>
  <title>Model Artifact Manager</title>
  <status>ready</status>
  <layer>surface</layer>
  <sequence>48</sequence>
  <implements>
    - Implementation Plan: auto_download configuration
    - PRD: 12-model artifact management and integrity
    - Constitution: reliability.model_verification
  </implements>
  <depends_on>
    - M03-F01 (ModelId)
    - M03-F11 (EmbeddingConfig)
    - M03-F12 (ModelRegistryConfig)
    - M03-L01 (ModelRegistry)
  </depends_on>
  <estimated_hours>5</estimated_hours>
</metadata>

<context>
Implement the Model Artifact Manager that handles downloading, verification, and
lifecycle management of the 12 embedding model files. For a 12-model pipeline,
a missing or corrupted model on disk will crash the system at runtime.

Key responsibilities:
- Verify SHA-256 checksums of downloaded .safetensors files
- Async download missing models from HuggingFace Hub at startup
- Handle download progress reporting and resumption
- Manage model file cache with size limits
- Provide model readiness checks before pipeline initialization

This is critical infrastructure that must complete before ModelRegistry initialization.
</context>

<definition_of_done>
  <signatures>
```rust
/// Model artifact metadata
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ModelArtifact {
    pub model_id: ModelId,
    pub repo_id: String,          // e.g., "intfloat/e5-large-v2"
    pub filename: String,         // e.g., "model.safetensors"
    pub sha256: String,           // expected hash
    pub size_bytes: u64,
    pub revision: Option<String>, // git revision or "main"
}

/// Download status for a model
#[derive(Debug, Clone)]
pub enum DownloadStatus {
    NotStarted,
    InProgress { bytes_downloaded: u64, total_bytes: u64 },
    Completed { path: PathBuf, verified: bool },
    Failed { error: String, retries: u32 },
}

/// Configuration for artifact manager
#[derive(Debug, Clone)]
pub struct ArtifactManagerConfig {
    pub cache_dir: PathBuf,
    pub auto_download: bool,
    pub verify_checksums: bool,
    pub max_concurrent_downloads: usize,
    pub download_timeout: Duration,
    pub retry_attempts: u32,
    pub hf_token: Option<String>,
}

pub struct ModelArtifactManager {
    config: ArtifactManagerConfig,
    manifests: HashMap<ModelId, ModelArtifact>,
    status: RwLock<HashMap<ModelId, DownloadStatus>>,
    client: reqwest::Client,
}

impl ModelArtifactManager {
    /// Create manager with configuration
    pub fn new(config: ArtifactManagerConfig) -> EmbeddingResult<Self>;

    /// Load artifact manifests from embedded data or file
    pub fn load_manifests(&mut self) -> EmbeddingResult<()>;

    /// Check if model is available locally
    pub fn is_available(&self, model_id: ModelId) -> bool;

    /// Get local path for model (None if not downloaded)
    pub fn get_path(&self, model_id: ModelId) -> Option<PathBuf>;

    /// Verify checksum of local model file
    pub async fn verify_checksum(&self, model_id: ModelId) -> EmbeddingResult<bool>;

    /// Download model from HuggingFace Hub
    pub async fn download(&self, model_id: ModelId) -> EmbeddingResult<PathBuf>;

    /// Download all missing models
    pub async fn ensure_all_models(&self) -> EmbeddingResult<()>;

    /// Get download status for model
    pub fn status(&self, model_id: ModelId) -> DownloadStatus;

    /// Get overall readiness status
    pub fn readiness_report(&self) -> ReadinessReport;

    /// Subscribe to download progress updates
    pub fn subscribe_progress(&self) -> broadcast::Receiver<ProgressEvent>;

    /// Clear cached model files
    pub async fn clear_cache(&self) -> EmbeddingResult<()>;

    /// Get total cache size
    pub fn cache_size(&self) -> u64;
}

/// Progress event for download tracking
#[derive(Debug, Clone)]
pub struct ProgressEvent {
    pub model_id: ModelId,
    pub bytes_downloaded: u64,
    pub total_bytes: u64,
    pub speed_bps: u64,
}

/// Overall readiness report
#[derive(Debug, Clone)]
pub struct ReadinessReport {
    pub ready_models: Vec<ModelId>,
    pub missing_models: Vec<ModelId>,
    pub failed_models: Vec<(ModelId, String)>,
    pub total_size_bytes: u64,
    pub downloaded_bytes: u64,
}
```
  </signatures>

  <constraints>
    - Async downloads: use reqwest with tokio runtime
    - Concurrent downloads limited by max_concurrent_downloads
    - SHA-256 verification using sha2 crate
    - Resume support: check existing partial downloads
    - HuggingFace Hub API: support authentication tokens
    - Progress broadcast: non-blocking event emission
    - Cache management: respect disk space limits
    - Error recovery: automatic retry with exponential backoff
    - Must complete before ModelRegistry initialization
  </constraints>

  <verification>
    <step>All 12 model manifests loaded correctly</step>
    <step>is_available returns true for existing files</step>
    <step>verify_checksum detects corrupted files</step>
    <step>download fetches from correct HuggingFace repo</step>
    <step>ensure_all_models downloads missing models</step>
    <step>Progress events emitted during download</step>
    <step>Retry logic works on transient failures</step>
    <step>Cache size accurately reported</step>
  </verification>
</definition_of_done>

<files_to_create>
  <file>crates/context-graph-embeddings/src/artifacts/manager.rs</file>
  <file>crates/context-graph-embeddings/src/artifacts/manifest.rs</file>
  <file>crates/context-graph-embeddings/src/artifacts/downloader.rs</file>
  <file>crates/context-graph-embeddings/src/artifacts/verification.rs</file>
  <file>crates/context-graph-embeddings/src/artifacts/mod.rs</file>
  <file>crates/context-graph-embeddings/src/artifacts/manifests.json</file>
</files_to_create>

<validation_criteria>
  <criterion>cargo check passes</criterion>
  <criterion>cargo test artifacts passes</criterion>
  <criterion>Download from HuggingFace works (integration test)</criterion>
  <criterion>Checksum verification catches corrupted files</criterion>
  <criterion>Progress events received during download</criterion>
  <criterion>Retry logic handles network failures</criterion>
</validation_criteria>
</task_spec>
```

## Implementation Notes

### Model Manifest (manifests.json)

```json
[
  {
    "model_id": "Semantic",
    "repo_id": "intfloat/e5-large-v2",
    "filename": "model.safetensors",
    "sha256": "abc123...",
    "size_bytes": 1340000000,
    "revision": "main"
  },
  {
    "model_id": "Causal",
    "repo_id": "allenai/longformer-base-4096",
    "filename": "model.safetensors",
    "sha256": "def456...",
    "size_bytes": 567000000,
    "revision": "main"
  }
  // ... 10 more models
]
```

### HuggingFace Download Logic

```rust
impl ModelArtifactManager {
    async fn download_from_hf(&self, artifact: &ModelArtifact) -> EmbeddingResult<PathBuf> {
        let url = format!(
            "https://huggingface.co/{}/resolve/{}/{}",
            artifact.repo_id,
            artifact.revision.as_deref().unwrap_or("main"),
            artifact.filename
        );

        let mut request = self.client.get(&url);
        if let Some(token) = &self.config.hf_token {
            request = request.bearer_auth(token);
        }

        let response = request.send().await?;
        let total_size = response.content_length().unwrap_or(artifact.size_bytes);

        let dest_path = self.cache_path(artifact);
        let mut file = tokio::fs::File::create(&dest_path).await?;
        let mut downloaded = 0u64;

        let mut stream = response.bytes_stream();
        while let Some(chunk) = stream.next().await {
            let chunk = chunk?;
            file.write_all(&chunk).await?;
            downloaded += chunk.len() as u64;

            // Emit progress event
            self.emit_progress(ProgressEvent {
                model_id: artifact.model_id,
                bytes_downloaded: downloaded,
                total_bytes: total_size,
                speed_bps: self.calculate_speed(downloaded),
            });
        }

        Ok(dest_path)
    }
}
```

### Integration with Pipeline Initialization

```rust
impl EmbeddingPipeline {
    pub async fn new(config: EmbeddingConfig) -> EmbeddingResult<Self> {
        // Step 0: Ensure all models are available
        let artifact_manager = ModelArtifactManager::new(config.artifacts.clone())?;

        if config.artifacts.auto_download {
            artifact_manager.ensure_all_models().await?;
        } else {
            let report = artifact_manager.readiness_report();
            if !report.missing_models.is_empty() {
                return Err(EmbeddingError::MissingModels(report.missing_models));
            }
        }

        // Step 1: Initialize ModelRegistry (models now guaranteed to exist)
        let registry = ModelRegistry::new(config.registry.clone()).await?;

        // ... rest of initialization
    }
}
```

---
*Task ID: M03-S13*
*Layer: Surface*
*Module: 03 - 12-Model Embedding Pipeline*
