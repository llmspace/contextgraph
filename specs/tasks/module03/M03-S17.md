# Task Specification: M03-S17

```xml
<task_spec id="M03-S17" version="1.0">
<metadata>
  <title>Fail-Safe Async Orchestrator (FusionInputAssembler)</title>
  <status>ready</status>
  <layer>surface</layer>
  <sequence>47</sequence>
  <implements>
    - PRD: <200ms P95 latency requirement
    - Constitution: embeddings.pipeline.resilience
    - Architecture: Graceful degradation under partial model failure
  </implements>
  <depends_on>M03-S01, M03-L17, M03-L23</depends_on>
  <estimated_hours>4</estimated_hours>
</metadata>

<context>
The pipeline executes 12 models in parallel, but what happens when the Causal model (E5)
times out or the Multimodal model (E10) crashes? Without explicit orchestration logic,
the pipeline would either hang indefinitely or fail completely.

This task implements the "FusionInputAssembler" - the async orchestration layer that:
1. Collects results from parallel model execution using tokio::JoinSet
2. Enforces a hard 150ms timeout (leaving 50ms budget for FuseMoE)
3. Decides if "enough" data is available to proceed (e.g., Semantic E1 MUST be present)
4. Gracefully degrades when optional models fail
5. Reports which models contributed to the final embedding

Key principle: "A partial embedding is better than no embedding" - but some models
(Semantic E1) are mandatory while others (HDC E9) can be skipped.

Performance targets:
- Collection timeout: 150ms hard limit
- Minimum required models: Semantic (E1) + at least 6 others
- Decision latency: <1ms after timeout
- Memory overhead: <1KB per in-flight request
</context>

<definition_of_done>
  <signatures>
```rust
use tokio::time::{timeout, Duration};
use tokio::task::JoinSet;

/// Model execution result with timing metadata
#[derive(Debug, Clone)]
pub struct ModelExecutionResult {
    pub model_id: ModelId,
    pub embedding: Option<ModelEmbedding>,
    pub latency_us: u64,
    pub status: ExecutionStatus,
}

/// Status of individual model execution
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum ExecutionStatus {
    /// Completed successfully
    Success,
    /// Timed out before completion
    Timeout,
    /// Failed with error
    Failed,
    /// Skipped (not required, prior failure)
    Skipped,
    /// Still running when collection ended
    Pending,
}

/// Policy for handling partial results
#[derive(Debug, Clone)]
pub struct PartialResultPolicy {
    /// Models that MUST be present (pipeline fails without them)
    pub required_models: Vec<ModelId>,
    /// Minimum number of successful models (excluding required)
    pub min_optional_models: usize,
    /// Allow fallback to zero-vectors for missing optional models
    pub allow_zero_fallback: bool,
    /// Hard timeout for collection phase
    pub collection_timeout: Duration,
}

impl Default for PartialResultPolicy {
    fn default() -> Self {
        Self {
            // Semantic E1 is mandatory - it's the "backbone" of the embedding
            required_models: vec![ModelId::Semantic],
            // Need at least 6 of the 11 optional models
            min_optional_models: 6,
            allow_zero_fallback: true,
            // 150ms leaves 50ms for FuseMoE
            collection_timeout: Duration::from_millis(150),
        }
    }
}

/// Assembled input for FuseMoE fusion
#[derive(Debug)]
pub struct FusionInput {
    /// Concatenated embeddings from successful models
    pub concatenated: ConcatenatedEmbedding,
    /// Which models contributed to this embedding
    pub contributing_models: Vec<ModelId>,
    /// Which models failed or timed out
    pub missing_models: Vec<ModelId>,
    /// Total collection latency
    pub collection_latency_us: u64,
    /// Individual model results for debugging
    pub model_results: Vec<ModelExecutionResult>,
}

/// Fail-safe async orchestrator for parallel model execution
pub struct FusionInputAssembler {
    policy: PartialResultPolicy,
    metrics: AssemblerMetrics,
}

impl FusionInputAssembler {
    /// Create assembler with policy
    pub fn new(policy: PartialResultPolicy) -> Self;

    /// Create with default policy
    pub fn with_defaults() -> Self;

    /// Collect results from parallel model execution with timeout
    ///
    /// This is the core orchestration method:
    /// 1. Waits for all tasks in JoinSet with timeout
    /// 2. Collects whatever results arrived within timeout
    /// 3. Validates against policy (required models, minimum count)
    /// 4. Fills missing optional models with zero vectors if allowed
    /// 5. Returns FusionInput or error if policy violated
    pub async fn collect_with_timeout(
        &self,
        join_set: &mut JoinSet<EmbeddingResult<ModelEmbedding>>,
        model_order: &[ModelId],
    ) -> EmbeddingResult<FusionInput>;

    /// Check if results meet policy requirements
    pub fn validate_results(
        &self,
        results: &[ModelExecutionResult],
    ) -> Result<(), PartialResultError>;

    /// Fill missing optional models with zero vectors
    fn fill_missing_with_zeros(
        &self,
        results: &mut Vec<ModelEmbedding>,
        missing: &[ModelId],
    );

    /// Get metrics about collection performance
    pub fn metrics(&self) -> &AssemblerMetrics;
}

/// Error when partial results don't meet policy
#[derive(Debug, Clone, thiserror::Error)]
pub enum PartialResultError {
    #[error("Required model {0:?} failed: {1}")]
    RequiredModelFailed(ModelId, String),

    #[error("Required model {0:?} timed out after {1}ms")]
    RequiredModelTimeout(ModelId, u64),

    #[error("Only {got} of minimum {min} optional models succeeded")]
    InsufficientModels { got: usize, min: usize },

    #[error("All models failed or timed out")]
    TotalFailure,
}

/// Metrics for monitoring assembler performance
#[derive(Debug, Default)]
pub struct AssemblerMetrics {
    /// Total collection attempts
    pub total_collections: AtomicU64,
    /// Collections that met policy fully
    pub full_success: AtomicU64,
    /// Collections that used fallback zeros
    pub partial_success: AtomicU64,
    /// Collections that failed policy
    pub policy_failures: AtomicU64,
    /// Average collection latency
    pub avg_latency_us: AtomicU64,
    /// Timeouts per model
    pub model_timeouts: [AtomicU64; 12],
}
```
  </signatures>

  <constraints>
    <constraint>Hard 150ms timeout enforced via tokio::time::timeout</constraint>
    <constraint>Semantic (E1) model is always required</constraint>
    <constraint>Minimum 7 total models must succeed (1 required + 6 optional)</constraint>
    <constraint>Zero-vector fallback only for optional models</constraint>
    <constraint>Must track which models contributed for debugging</constraint>
    <constraint>Must be cancel-safe (tasks can be dropped)</constraint>
    <constraint>Thread-safe metrics collection</constraint>
    <constraint>Memory efficient - no unbounded buffering</constraint>
  </constraints>
</definition_of_done>

<files_to_create>
  <file>crates/context-graph-embeddings/src/pipeline/assembler.rs</file>
  <file>crates/context-graph-embeddings/src/pipeline/policy.rs</file>
</files_to_create>

<validation_criteria>
  <criterion>cargo check passes</criterion>
  <criterion>cargo clippy passes with no warnings</criterion>
  <criterion>collect_with_timeout returns within 160ms (150ms + overhead)</criterion>
  <criterion>Missing required model returns RequiredModelFailed</criterion>
  <criterion>Timeout on required model returns RequiredModelTimeout</criterion>
  <criterion>7+ successful models returns FusionInput</criterion>
  <criterion>6 or fewer successful models returns InsufficientModels</criterion>
  <criterion>Zero-fallback correctly fills missing dimensions</criterion>
  <criterion>Metrics accurately track success/failure rates</criterion>
</validation_criteria>
</task_spec>
```

## Implementation Notes

### Collection Flow
```
Parallel Model Execution (12 tasks)
        |
        v
[JoinSet::join_next_with_timeout]
        |
        +---> Model completes --> Store result
        |
        +---> Timeout (150ms) --> Stop waiting
        |
        v
[Validate Results Against Policy]
        |
        +---> Required model missing? --> ERROR
        |
        +---> < 7 models? --> ERROR
        |
        +---> >= 7 models? --> Continue
        |
        v
[Fill Missing Optional Models]
        |
        +---> Zero-vector fallback for missing
        |
        v
[Build ConcatenatedEmbedding]
        |
        v
[Return FusionInput]
```

### Core Collection Logic
```rust
impl FusionInputAssembler {
    pub async fn collect_with_timeout(
        &self,
        join_set: &mut JoinSet<EmbeddingResult<ModelEmbedding>>,
        model_order: &[ModelId],
    ) -> EmbeddingResult<FusionInput> {
        let start = Instant::now();
        let deadline = start + self.policy.collection_timeout;
        let mut results: HashMap<ModelId, ModelExecutionResult> = HashMap::new();

        // Collect results until timeout or all complete
        loop {
            let remaining = deadline.saturating_duration_since(Instant::now());
            if remaining.is_zero() {
                break; // Hard timeout reached
            }

            match timeout(remaining, join_set.join_next()).await {
                // Task completed within timeout
                Ok(Some(Ok(Ok(embedding)))) => {
                    let model_id = embedding.model_id;
                    results.insert(model_id, ModelExecutionResult {
                        model_id,
                        embedding: Some(embedding),
                        latency_us: start.elapsed().as_micros() as u64,
                        status: ExecutionStatus::Success,
                    });
                }
                // Task failed
                Ok(Some(Ok(Err(e)))) => {
                    // Extract model_id from error if possible
                    if let Some(model_id) = e.model_id() {
                        results.insert(model_id, ModelExecutionResult {
                            model_id,
                            embedding: None,
                            latency_us: start.elapsed().as_micros() as u64,
                            status: ExecutionStatus::Failed,
                        });
                    }
                }
                // Task panicked
                Ok(Some(Err(join_error))) => {
                    warn!("Model task panicked: {}", join_error);
                }
                // All tasks complete
                Ok(None) => break,
                // Timeout waiting for next task
                Err(_) => break,
            }
        }

        // Mark remaining tasks as pending/timeout
        for model_id in model_order {
            if !results.contains_key(model_id) {
                let status = if self.policy.required_models.contains(model_id) {
                    ExecutionStatus::Timeout
                } else {
                    ExecutionStatus::Pending
                };
                results.insert(*model_id, ModelExecutionResult {
                    model_id: *model_id,
                    embedding: None,
                    latency_us: self.policy.collection_timeout.as_micros() as u64,
                    status,
                });
            }
        }

        // Validate against policy
        let result_vec: Vec<_> = results.values().cloned().collect();
        self.validate_results(&result_vec)?;

        // Build fusion input
        self.build_fusion_input(results, start.elapsed())
    }

    fn validate_results(
        &self,
        results: &[ModelExecutionResult],
    ) -> Result<(), PartialResultError> {
        // Check required models
        for required in &self.policy.required_models {
            match results.iter().find(|r| r.model_id == *required) {
                Some(r) if r.status == ExecutionStatus::Success => {}
                Some(r) if r.status == ExecutionStatus::Timeout => {
                    return Err(PartialResultError::RequiredModelTimeout(
                        *required,
                        r.latency_us / 1000,
                    ));
                }
                Some(r) => {
                    return Err(PartialResultError::RequiredModelFailed(
                        *required,
                        format!("{:?}", r.status),
                    ));
                }
                None => {
                    return Err(PartialResultError::RequiredModelFailed(
                        *required,
                        "not found".to_string(),
                    ));
                }
            }
        }

        // Count successful models
        let success_count = results.iter()
            .filter(|r| r.status == ExecutionStatus::Success)
            .count();

        let required_count = self.policy.required_models.len();
        let optional_success = success_count.saturating_sub(required_count);

        if optional_success < self.policy.min_optional_models {
            return Err(PartialResultError::InsufficientModels {
                got: optional_success,
                min: self.policy.min_optional_models,
            });
        }

        Ok(())
    }

    fn build_fusion_input(
        &self,
        results: HashMap<ModelId, ModelExecutionResult>,
        total_latency: Duration,
    ) -> EmbeddingResult<FusionInput> {
        let mut embeddings = Vec::with_capacity(12);
        let mut contributing = Vec::new();
        let mut missing = Vec::new();

        // Collect in canonical order
        for model_id in ModelId::iter() {
            match results.get(&model_id) {
                Some(r) if r.embedding.is_some() => {
                    embeddings.push(r.embedding.clone().unwrap());
                    contributing.push(model_id);
                }
                _ => {
                    if self.policy.allow_zero_fallback {
                        embeddings.push(ModelEmbedding::zero(model_id));
                        missing.push(model_id);
                    }
                }
            }
        }

        let concatenated = ConcatenatedEmbedding::from_model_embeddings(embeddings)?;

        Ok(FusionInput {
            concatenated,
            contributing_models: contributing,
            missing_models: missing,
            collection_latency_us: total_latency.as_micros() as u64,
            model_results: results.into_values().collect(),
        })
    }
}
```

### Zero-Vector Fallback
```rust
impl ModelEmbedding {
    /// Create zero-vector embedding for missing model
    pub fn zero(model_id: ModelId) -> Self {
        let dim = ModelDimensions::get(model_id);
        Self {
            model_id,
            vector: vec![0.0; dim],
            latency_us: 0,
            normalized: true, // Zero vector is "normalized" (no direction)
        }
    }
}
```

### Integration with Pipeline
```rust
impl EmbeddingPipeline {
    pub async fn embed(&self, input: &str) -> EmbeddingResult<FusedEmbedding> {
        // Spawn all models in parallel
        let mut join_set = JoinSet::new();
        for model_id in ModelId::iter() {
            let model = self.registry.get(model_id)?;
            let input = input.to_string();
            join_set.spawn(async move {
                model.embed(&input).await
            });
        }

        // Collect with timeout and policy enforcement
        let fusion_input = self.assembler
            .collect_with_timeout(&mut join_set, &ModelId::all())
            .await?;

        // Log degradation if any models missing
        if !fusion_input.missing_models.is_empty() {
            warn!(
                "Embedding completed with {} missing models: {:?}",
                fusion_input.missing_models.len(),
                fusion_input.missing_models
            );
        }

        // Run FuseMoE on collected embeddings
        self.fusemoe.fuse(&fusion_input.concatenated).await
    }
}
```

---
*Task ID: M03-S17*
*Layer: Surface*
*Module: 03 - 12-Model Embedding Pipeline*
