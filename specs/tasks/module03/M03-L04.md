<?xml version="1.0" encoding="UTF-8"?>
<task_spec id="M03-L04" version="1.0">
<metadata>
  <title>Temporal-Recent Model (E2 - Exponential Decay)</title>
  <status>ready</status>
  <layer>logic</layer>
  <sequence>4</sequence>
  <implements>PRD: E2 Temporal-Recent embedding, 512D output, custom computed</implements>
  <depends_on>M03-F09</depends_on>
  <estimated_hours>3</estimated_hours>
</metadata>

<context>
Implement custom temporal embedding using exponential decay weighting to encode
recency information. This model produces 512D vectors that capture how recently
content was created or accessed.

Model specifications:
- Type: Custom computed (no pretrained weights)
- Output dimension: 512D
- Encoding: Exponential decay based on time delta
- Formula: weight = exp(-decay_rate * time_delta)

The temporal-recent model captures recency signals that help prioritize
recent information in retrieval. It uses multiple decay rates to capture
different time scales (minutes, hours, days, weeks).
</context>

<definition_of_done>
  <signatures>
```rust
pub struct TemporalRecentModel {
    decay_rates: Vec<f32>,
    time_scales: Vec<Duration>,
    reference_time: Option<DateTime<Utc>>,
    output_dim: usize,
}

impl TemporalRecentModel {
    /// Create new temporal-recent model
    pub fn new() -> Self;

    /// Create with custom decay rates
    pub fn with_decay_rates(rates: Vec<f32>) -> Self;

    /// Set reference time for relative calculations
    pub fn set_reference_time(&mut self, time: DateTime<Utc>);

    /// Compute decay embedding for a timestamp
    fn compute_decay_embedding(&self, timestamp: DateTime<Utc>) -> Vec<f32>;

    /// Extract timestamp from input (if available)
    fn extract_timestamp(&self, input: &ModelInput) -> Option<DateTime<Utc>>;
}

#[async_trait]
impl EmbeddingModel for TemporalRecentModel {
    fn model_id(&self) -> ModelId { ModelId::TemporalRecent }
    fn dimension(&self) -> usize { 512 }
    fn max_tokens(&self) -> usize { 0 } // Not token-based
    fn supported_inputs(&self) -> &[InputType] { &[InputType::Text] }

    fn is_loaded(&self) -> bool { true } // Always loaded (no weights)
    async fn load(&self) -> EmbeddingResult<()> { Ok(()) }
    async fn unload(&self) -> EmbeddingResult<()> { Ok(()) }

    async fn embed(&self, input: &ModelInput) -> EmbeddingResult<ModelEmbedding>;
    async fn embed_batch(&self, inputs: &[ModelInput]) -> EmbeddingResult<Vec<ModelEmbedding>>;

    fn memory_usage_bytes(&self) -> usize { std::mem::size_of::<Self>() }
    fn warmup_complete(&self) -> bool { true }
}
```
  </signatures>

  <constraints>
    <constraint>Uses exponential decay: weight = exp(-decay_rate * time_delta)</constraint>
    <constraint>Multiple decay rates for different time scales</constraint>
    <constraint>Default time scales: 1 hour, 1 day, 1 week, 1 month</constraint>
    <constraint>is_custom() returns true via ModelId::TemporalRecent.is_custom()</constraint>
    <constraint>load() is no-op since no pretrained weights needed</constraint>
    <constraint>dimension() returns 512</constraint>
    <constraint>If no timestamp available, uses current time</constraint>
    <constraint>Output concatenates decay values at multiple scales</constraint>
  </constraints>

  <verification>
    <step>Model is always "loaded" (is_loaded returns true)</step>
    <step>embed() returns 512D vector</step>
    <step>Recent timestamps produce higher values</step>
    <step>Old timestamps decay toward zero</step>
    <step>Different time scales captured in embedding</step>
    <step>Deterministic output for same timestamp</step>
    <step>Latency under 100 microseconds (pure computation)</step>
  </verification>
</definition_of_done>

<files_to_create>
  <file>crates/context-graph-embeddings/src/models/custom/temporal_recent.rs</file>
  <file>crates/context-graph-embeddings/src/models/custom/mod.rs</file>
</files_to_create>

<validation_criteria>
  <criterion>cargo check passes</criterion>
  <criterion>cargo test passes</criterion>
  <criterion>Pure Rust implementation, no external dependencies</criterion>
  <criterion>Numerical stability verified</criterion>
</validation_criteria>
</task_spec>
