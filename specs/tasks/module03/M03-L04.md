# M03-L04: Temporal-Recent Model (E2 - Exponential Decay)

## Task Metadata
| Field | Value |
|-------|-------|
| **ID** | M03-L04 |
| **Layer** | Logic |
| **Status** | Complete |
| **Depends On** | M03-F09 (types module), M03-F16 (module structure) |
| **Implements** | PRD E2: Temporal-Recent embedding, 512D output, custom computed |
| **Constitution Ref** | embeddings.models.E2_Temporal_Recent |

---

## Critical Context for AI Agent

### What This Task Is
Implement the **TemporalRecentModel** - a custom embedding model (E2) that produces 512-dimensional vectors encoding temporal recency using exponential decay. This model captures "how recently" content was created/accessed.

### Key Facts
- **NO pretrained weights** - pure computation based on timestamps
- **512D output** - matches `ModelId::TemporalRecent.dimension()` in `crates/context-graph-embeddings/src/types/model_id.rs:89`
- **Custom model** - `ModelId::TemporalRecent.is_custom()` returns `true` (line 124)
- **Always "loaded"** - no weight files needed, `is_initialized()` always returns `true` after construction
- **Latency budget**: <2ms per constitution.yaml

### Where Files Go
```
crates/context-graph-embeddings/src/models/
├── mod.rs                      # UPDATE: Add `pub mod custom;` export
├── custom/
│   ├── mod.rs                  # NEW: Exports TemporalRecentModel
│   └── temporal_recent.rs      # NEW: Main implementation
```

---

## Existing Codebase Patterns to Follow

### 1. EmbeddingModel Trait (MUST implement exactly)
Location: `crates/context-graph-embeddings/src/traits/embedding_model.rs`

```rust
#[async_trait]
pub trait EmbeddingModel: Send + Sync {
    fn model_id(&self) -> ModelId;
    fn supported_input_types(&self) -> &[InputType];
    async fn embed(&self, input: &ModelInput) -> EmbeddingResult<ModelEmbedding>;
    fn is_initialized(&self) -> bool;

    // Default implementations provided (DO NOT override):
    fn supports_input_type(&self, input_type: InputType) -> bool;
    fn dimension(&self) -> usize;        // delegates to model_id().dimension()
    fn projected_dimension(&self) -> usize;
    fn latency_budget_ms(&self) -> u32;
    fn max_tokens(&self) -> usize;
    fn is_pretrained(&self) -> bool;
    fn validate_input(&self, input: &ModelInput) -> EmbeddingResult<()>;
}
```

**CRITICAL**: The trait has EXACTLY 4 required methods. The old task spec was WRONG about `is_loaded`, `load`, `unload`, `memory_usage_bytes`, `warmup_complete`, `embed_batch` - these DO NOT exist in the trait.

### 2. Error Types to Use
Location: `crates/context-graph-embeddings/src/error.rs`

Key errors:
- `EmbeddingError::UnsupportedModality { model_id, input_type }` - for non-Text inputs
- `EmbeddingError::InvalidValue { index, value }` - for NaN/Inf in output
- `EmbeddingError::InternalError { message }` - for unexpected failures

### 3. ModelInput Structure
Location: `crates/context-graph-embeddings/src/types/input.rs`

```rust
pub enum ModelInput {
    Text { content: String, instruction: Option<String> },
    Code { content: String, language: String },
    Image { data: Vec<u8>, format: ImageFormat },
    Audio { data: Vec<u8>, format: AudioFormat, sample_rate: u32 },
}
```

**Timestamp extraction**: ModelInput does NOT have a native timestamp field. You must:
1. Parse timestamp from `instruction` field if provided (format: ISO 8601 or Unix epoch)
2. Fall back to `chrono::Utc::now()` if no timestamp available

### 4. ModelEmbedding Output
Location: `crates/context-graph-embeddings/src/types/embedding.rs`

```rust
pub struct ModelEmbedding {
    pub model_id: ModelId,
    pub vector: Vec<f32>,
    pub latency_us: u64,
    pub attention_weights: Option<Vec<f32>>,
    pub is_projected: bool,
}

impl ModelEmbedding {
    pub fn new(model_id: ModelId, vector: Vec<f32>, latency_us: u64) -> Self;
    pub fn validate(&self) -> EmbeddingResult<()>;  // checks dimension, NaN, Inf
}
```

### 5. Reference Implementation Pattern
Follow `SemanticModel` in `crates/context-graph-embeddings/src/models/pretrained/semantic.rs`:
- Uses `AtomicBool` for thread-safe loaded state
- Uses `std::time::Instant` to track latency
- Returns deterministic embeddings based on input hash
- Validates input type before processing

---

## Exact Implementation Requirements

### TemporalRecentModel Structure

```rust
use chrono::{DateTime, Duration, Utc};
use std::sync::atomic::{AtomicBool, Ordering};
use async_trait::async_trait;

/// Constants
pub const TEMPORAL_RECENT_DIMENSION: usize = 512;
pub const DEFAULT_DECAY_RATES: [f32; 4] = [
    1.0 / 3600.0,       // 1 hour scale
    1.0 / 86400.0,      // 1 day scale
    1.0 / 604800.0,     // 1 week scale
    1.0 / 2592000.0,    // 1 month scale
];

pub struct TemporalRecentModel {
    /// Decay rates for different time scales (seconds)
    decay_rates: Vec<f32>,

    /// Reference time for relative calculations (None = use current time)
    reference_time: Option<DateTime<Utc>>,

    /// Always true for custom models (no weights to load)
    initialized: AtomicBool,
}
```

### Core Algorithm

The embedding encodes temporal recency across multiple time scales using exponential decay:

```
For each time scale i:
    time_delta = (reference_time - input_timestamp).num_seconds() as f32
    decay_value = exp(-decay_rate[i] * time_delta)
```

The 512D vector is structured as:
- 4 time scales x 128 features per scale = 512 dimensions
- Each 128-feature block encodes the decay at that scale with phase variations

```rust
fn compute_decay_embedding(&self, timestamp: DateTime<Utc>) -> Vec<f32> {
    let reference = self.reference_time.unwrap_or_else(Utc::now);
    let time_delta_secs = (reference - timestamp).num_seconds() as f32;

    let mut vector = Vec::with_capacity(TEMPORAL_RECENT_DIMENSION);

    for &decay_rate in &self.decay_rates {
        // Clamp to prevent numerical issues with very old timestamps
        let clamped_delta = time_delta_secs.max(0.0).min(31536000.0); // max 1 year
        let base_decay = (-decay_rate * clamped_delta).exp();

        // Generate 128 features for this time scale with phase variations
        for i in 0..128 {
            let phase = (i as f32) * std::f32::consts::PI / 64.0;
            let value = base_decay * (phase + clamped_delta * decay_rate * 0.001).cos();
            vector.push(value);
        }
    }

    // L2 normalize
    let norm: f32 = vector.iter().map(|x| x * x).sum::<f32>().sqrt();
    if norm > f32::EPSILON {
        for v in &mut vector {
            *v /= norm;
        }
    }

    vector
}
```

### Timestamp Extraction from ModelInput

```rust
fn extract_timestamp(&self, input: &ModelInput) -> DateTime<Utc> {
    match input {
        ModelInput::Text { instruction, .. } => {
            instruction.as_ref()
                .and_then(|inst| Self::parse_timestamp(inst))
                .unwrap_or_else(Utc::now)
        }
        // For other input types, use current time
        _ => Utc::now(),
    }
}

fn parse_timestamp(instruction: &str) -> Option<DateTime<Utc>> {
    // Try ISO 8601 format: "timestamp:2024-01-15T10:30:00Z"
    if let Some(ts_str) = instruction.strip_prefix("timestamp:") {
        if let Ok(dt) = DateTime::parse_from_rfc3339(ts_str.trim()) {
            return Some(dt.with_timezone(&Utc));
        }
    }

    // Try Unix epoch: "epoch:1705315800"
    if let Some(epoch_str) = instruction.strip_prefix("epoch:") {
        if let Ok(secs) = epoch_str.trim().parse::<i64>() {
            return DateTime::from_timestamp(secs, 0).map(|dt| dt.with_timezone(&Utc));
        }
    }

    None
}
```

---

## Files to Create

### 1. `crates/context-graph-embeddings/src/models/custom/mod.rs`

```rust
//! Custom embedding model implementations.
//!
//! Custom models (E2-E4, E9) are computed from scratch without pretrained weights.
//! They implement specialized mathematical encodings:
//! - TemporalRecent (E2): Exponential decay for recency
//! - TemporalPeriodic (E3): Fourier basis for periodicity
//! - TemporalPositional (E4): Sinusoidal positional encoding
//! - Hdc (E9): Hyperdimensional computing

mod temporal_recent;

pub use temporal_recent::{TemporalRecentModel, TEMPORAL_RECENT_DIMENSION, DEFAULT_DECAY_RATES};
```

### 2. `crates/context-graph-embeddings/src/models/custom/temporal_recent.rs`

Full implementation with all methods and comprehensive tests (see Implementation Requirements above).

### 3. Update `crates/context-graph-embeddings/src/models/mod.rs`

Add after line 47 (`pub mod pretrained;`):
```rust
pub mod custom;
```

Add to exports after line 51:
```rust
pub use custom::{TemporalRecentModel, TEMPORAL_RECENT_DIMENSION, DEFAULT_DECAY_RATES};
```

---

## Verification Requirements

### Definition of Done Checklist

- [ ] `cargo check -p context-graph-embeddings` passes
- [ ] `cargo test -p context-graph-embeddings` passes with all new tests
- [ ] `cargo clippy -p context-graph-embeddings -- -D warnings` passes
- [ ] TemporalRecentModel implements EmbeddingModel trait
- [ ] `model.model_id()` returns `ModelId::TemporalRecent`
- [ ] `model.dimension()` returns 512 (via default impl)
- [ ] `model.is_initialized()` returns true after construction
- [ ] `model.is_pretrained()` returns false (via default impl)
- [ ] embed() returns exactly 512D vector
- [ ] Vector is L2 normalized (norm within 0.001 of 1.0)
- [ ] No NaN or Inf values in output
- [ ] Recent timestamps produce higher values than old timestamps
- [ ] Same timestamp produces identical embedding (deterministic)
- [ ] Latency < 2ms (pure computation, no I/O)

---

## Full State Verification Protocol

### 1. Source of Truth
The embedding output vector stored in `ModelEmbedding.vector`.

### 2. Execute & Inspect Test

```rust
#[tokio::test]
async fn test_source_of_truth_verification() {
    let model = TemporalRecentModel::new();
    let now = Utc::now();
    let input = ModelInput::text_with_instruction(
        "test content",
        &format!("timestamp:{}", now.to_rfc3339())
    ).unwrap();

    // Execute
    let embedding = model.embed(&input).await.unwrap();

    // INSPECT SOURCE OF TRUTH
    println!("=== SOURCE OF TRUTH VERIFICATION ===");
    println!("model_id: {:?}", embedding.model_id);
    println!("vector.len(): {}", embedding.vector.len());
    println!("vector[0..5]: {:?}", &embedding.vector[0..5]);
    println!("latency_us: {}", embedding.latency_us);

    let norm: f32 = embedding.vector.iter().map(|x| x * x).sum::<f32>().sqrt();
    println!("L2 norm: {}", norm);

    let has_nan = embedding.vector.iter().any(|x| x.is_nan());
    let has_inf = embedding.vector.iter().any(|x| x.is_infinite());
    println!("has_nan: {}, has_inf: {}", has_nan, has_inf);

    // VERIFY
    assert_eq!(embedding.model_id, ModelId::TemporalRecent);
    assert_eq!(embedding.vector.len(), 512);
    assert!((norm - 1.0).abs() < 0.001);
    assert!(!has_nan && !has_inf);
}
```

### 3. Boundary & Edge Case Audit (MANDATORY)

#### Edge Case 1: Very Old Timestamp (1 year ago)
```rust
#[tokio::test]
async fn test_edge_case_1_very_old_timestamp() {
    let model = TemporalRecentModel::new();
    let one_year_ago = Utc::now() - Duration::days(365);

    println!("=== EDGE CASE 1: Very Old Timestamp ===");
    println!("BEFORE: timestamp = {}", one_year_ago);

    let input = ModelInput::text_with_instruction(
        "old content",
        &format!("timestamp:{}", one_year_ago.to_rfc3339())
    ).unwrap();

    let embedding = model.embed(&input).await.unwrap();

    println!("AFTER: vector[0..5] = {:?}", &embedding.vector[0..5]);
    println!("AFTER: mean value = {}",
        embedding.vector.iter().sum::<f32>() / embedding.vector.len() as f32);

    // Old timestamps should have decayed values (smaller magnitude before normalization)
    assert_eq!(embedding.vector.len(), 512);
    // Values should be valid (no NaN/Inf)
    assert!(embedding.vector.iter().all(|x| x.is_finite()));
}
```

#### Edge Case 2: Future Timestamp (negative delta)
```rust
#[tokio::test]
async fn test_edge_case_2_future_timestamp() {
    let model = TemporalRecentModel::new();
    let future = Utc::now() + Duration::days(30);

    println!("=== EDGE CASE 2: Future Timestamp ===");
    println!("BEFORE: timestamp = {} (future)", future);

    let input = ModelInput::text_with_instruction(
        "future content",
        &format!("timestamp:{}", future.to_rfc3339())
    ).unwrap();

    let embedding = model.embed(&input).await.unwrap();

    println!("AFTER: vector[0..5] = {:?}", &embedding.vector[0..5]);

    // Future timestamps should still produce valid output
    // (clamp delta to 0 minimum)
    assert_eq!(embedding.vector.len(), 512);
    assert!(embedding.vector.iter().all(|x| x.is_finite()));
}
```

#### Edge Case 3: No Timestamp (fallback to current time)
```rust
#[tokio::test]
async fn test_edge_case_3_no_timestamp() {
    let model = TemporalRecentModel::new();

    println!("=== EDGE CASE 3: No Timestamp (Fallback) ===");
    println!("BEFORE: input has no timestamp instruction");

    let input = ModelInput::text("content without timestamp").unwrap();

    let embedding = model.embed(&input).await.unwrap();

    println!("AFTER: vector[0..5] = {:?}", &embedding.vector[0..5]);
    println!("AFTER: Should use current time as fallback");

    // Should use current time = minimal decay = high values
    assert_eq!(embedding.vector.len(), 512);
    assert!(embedding.vector.iter().all(|x| x.is_finite()));
}
```

### 4. Evidence of Success Log

Run this test to produce verification evidence:

```rust
#[tokio::test]
async fn test_evidence_of_success() {
    println!("\n========================================");
    println!("M03-L04 EVIDENCE OF SUCCESS");
    println!("========================================\n");

    let model = TemporalRecentModel::new();

    // Test 1: Model metadata
    println!("1. MODEL METADATA:");
    println!("   model_id = {:?}", model.model_id());
    println!("   dimension = {}", model.dimension());
    println!("   is_initialized = {}", model.is_initialized());
    println!("   is_pretrained = {}", model.is_pretrained());
    println!("   latency_budget_ms = {}", model.latency_budget_ms());

    // Test 2: Embed and verify output
    let now = Utc::now();
    let input = ModelInput::text_with_instruction(
        "test",
        &format!("timestamp:{}", now.to_rfc3339())
    ).unwrap();

    let start = std::time::Instant::now();
    let embedding = model.embed(&input).await.unwrap();
    let elapsed = start.elapsed();

    println!("\n2. EMBEDDING OUTPUT:");
    println!("   vector length = {}", embedding.vector.len());
    println!("   latency = {:?}", elapsed);
    println!("   first 10 values = {:?}", &embedding.vector[0..10]);

    let norm: f32 = embedding.vector.iter().map(|x| x * x).sum::<f32>().sqrt();
    println!("   L2 norm = {}", norm);

    // Test 3: Recency ordering
    let old_input = ModelInput::text_with_instruction(
        "test",
        &format!("timestamp:{}", (now - Duration::days(30)).to_rfc3339())
    ).unwrap();
    let old_embedding = model.embed(&old_input).await.unwrap();

    let recent_sum: f32 = embedding.vector[0..128].iter().sum();
    let old_sum: f32 = old_embedding.vector[0..128].iter().sum();

    println!("\n3. RECENCY ORDERING:");
    println!("   recent (now) first block sum = {}", recent_sum);
    println!("   old (30 days) first block sum = {}", old_sum);
    println!("   recent > old = {}", recent_sum.abs() > old_sum.abs());

    println!("\n========================================");
    println!("ALL CHECKS PASSED");
    println!("========================================\n");

    assert!(elapsed.as_millis() < 2, "Latency exceeded 2ms budget");
}
```

---

## Anti-Patterns to Avoid (from constitution.yaml)

- **AP-001**: Never use `unwrap()` in prod - use `expect()` with context or `?`
- **AP-003**: No magic numbers - define constants for decay rates
- **AP-009**: NaN/Infinity in output - clamp values to valid range
- **AP-015**: GPU alloc without pool - this is CPU-only, no GPU

---

## Cargo.toml Dependencies

The following are ALREADY present in `crates/context-graph-embeddings/Cargo.toml`:
- `chrono` is available via workspace (add to Cargo.toml if not present)
- `async-trait = { workspace = true }`
- `tokio = { workspace = true }`

If chrono is not in Cargo.toml, add:
```toml
chrono = { version = "0.4", features = ["serde"] }
```

---

## Testing Commands

```bash
# Build check
cargo check -p context-graph-embeddings

# Run all tests
cargo test -p context-graph-embeddings

# Run only TemporalRecentModel tests
cargo test -p context-graph-embeddings temporal_recent

# Run with output for verification
cargo test -p context-graph-embeddings test_evidence_of_success -- --nocapture

# Lint check
cargo clippy -p context-graph-embeddings -- -D warnings
```

---

## Manual Output Verification (MANDATORY)

After implementing, you MUST manually verify outputs exist:

1. **Check file creation**:
   ```bash
   ls -la crates/context-graph-embeddings/src/models/custom/
   # Expected: mod.rs, temporal_recent.rs
   ```

2. **Check module exports**:
   ```bash
   grep -n "pub mod custom" crates/context-graph-embeddings/src/models/mod.rs
   # Expected: line showing "pub mod custom;"
   ```

3. **Run tests with output**:
   ```bash
   cargo test -p context-graph-embeddings test_evidence_of_success -- --nocapture
   # Expected: See "ALL CHECKS PASSED" in output
   ```

4. **Verify no regressions**:
   ```bash
   cargo test -p context-graph-embeddings
   # Expected: All tests pass
   ```

---

## Final Verification Checklist (Sherlock Protocol)

After implementation is complete, the `sherlock-holmes` subagent MUST verify:

1. **File Existence**: All 3 files exist in correct paths
2. **Trait Implementation**: EmbeddingModel fully implemented with exactly 4 required methods
3. **Dimension Accuracy**: embed() returns exactly 512D vector
4. **Normalization**: L2 norm of output within 0.001 of 1.0
5. **Determinism**: Same input produces identical output
6. **Recency Ordering**: Recent timestamps produce different values than old
7. **Edge Cases**: All 3 edge case tests pass
8. **Performance**: Latency < 2ms
9. **No Regressions**: All existing tests still pass
10. **Code Quality**: No clippy warnings

**The task is NOT complete until sherlock-holmes verifies all 10 checks pass.**

---

## Sherlock Verification (2026-01-01)

**VERDICT: VERIFIED - ALL 10 CHECKS PASSED**

| # | Check | Status | Evidence |
|---|-------|--------|----------|
| 1 | File Existence | PASS | `mod.rs` (554 bytes), `temporal_recent.rs` (32,347 bytes) in correct paths |
| 2 | Trait Implementation | PASS | All 4 required methods implemented (lines 232-267) |
| 3 | Dimension Accuracy | PASS | `test_embed_returns_512d_vector` passed |
| 4 | Normalization | PASS | L2 norm = 1.0 exactly |
| 5 | Determinism | PASS | `test_deterministic_with_same_timestamp` passed |
| 6 | Recency Ordering | PASS | `test_different_timestamps_different_embeddings` passed |
| 7 | Edge Cases | PASS | All 3 edge case tests passed |
| 8 | Performance | PASS | Latency = 60.561µs (well under 2ms) |
| 9 | No Regressions | PASS | 608 tests passed, 0 failed |
| 10 | Code Quality | PASS | Zero clippy warnings |

**Files Created:**
- `crates/context-graph-embeddings/src/models/custom/mod.rs`
- `crates/context-graph-embeddings/src/models/custom/temporal_recent.rs`

**Files Modified:**
- `crates/context-graph-embeddings/src/models/mod.rs` (added custom module exports)
- `crates/context-graph-embeddings/Cargo.toml` (added chrono dependency)
