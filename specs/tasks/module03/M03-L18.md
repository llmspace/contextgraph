<?xml version="1.0" encoding="UTF-8"?>
<task_spec id="M03-L18" version="1.0">
<metadata>
  <title>CacheEntry and CacheKey Types</title>
  <status>ready</status>
  <layer>logic</layer>
  <sequence>18</sequence>
  <implements>PRD-EMB-003: Embedding Cache System</implements>
  <depends_on>M03-F05, M03-F15</depends_on>
  <estimated_hours>1.5</estimated_hours>
</metadata>

<context>
Implement cache entry and key types for the embedding cache system. The CacheKey
provides a unique identifier for cached embeddings based on content hash. The
CacheEntry stores the cached FusedEmbedding along with metadata for LRU/LFU
eviction policies including creation time, last access time, and access count.

These types are fundamental to the caching layer which targets >80% hit rate
and <100us lookup latency.
</context>

<definition_of_done>
  <signatures>
```rust
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub struct CacheKey {
    pub content_hash: u64,
}

impl CacheKey {
    pub fn from_content(content: &str) -> Self;
    pub fn from_input(input: &ModelInput) -> Self;
}

#[derive(Debug)]
pub struct CacheEntry {
    pub embedding: FusedEmbedding,
    pub created_at: Instant,
    pub last_accessed: AtomicU64,
    pub access_count: AtomicU32,
}

impl CacheEntry {
    pub fn new(embedding: FusedEmbedding) -> Self;
    pub fn touch(&self);
    pub fn age(&self) -> Duration;
    pub fn is_expired(&self, ttl: Duration) -> bool;
    pub fn memory_size(&self) -> usize;
}
```
  </signatures>

  <constraints>
    <constraint>CacheKey must be Copy and cheap to create</constraint>
    <constraint>Use xxhash or similar fast hash for content_hash</constraint>
    <constraint>AtomicU64 for last_accessed enables lock-free updates</constraint>
    <constraint>AtomicU32 for access_count supports LFU policy</constraint>
    <constraint>memory_size() includes FusedEmbedding vector and metadata</constraint>
    <constraint>CacheKey implements Hash trait for HashMap usage</constraint>
    <constraint>Instant-based timestamps for age calculation</constraint>
  </constraints>
</definition_of_done>

<files_to_create>
  <file>crates/context-graph-embeddings/src/cache/types.rs</file>
</files_to_create>

<validation_criteria>
  <criterion>cargo check passes</criterion>
  <criterion>cargo clippy passes without warnings</criterion>
  <criterion>Unit test: CacheKey from same content produces same hash</criterion>
  <criterion>Unit test: CacheKey from different content produces different hash</criterion>
  <criterion>Unit test: CacheEntry touch() updates last_accessed</criterion>
  <criterion>Unit test: CacheEntry is_expired() returns correct value</criterion>
  <criterion>Unit test: memory_size() returns accurate byte count</criterion>
</validation_criteria>

<implementation_notes>
Use xxhash3 (xxhash-rust crate) for fast content hashing:
- 64-bit hash provides good collision resistance
- ~10GB/s hashing speed on modern CPUs

For AtomicU64 timestamp storage:
- Store as nanos since process start (Instant::now())
- Use Ordering::Relaxed for touch() - eventual consistency is fine
</implementation_notes>
</task_spec>
