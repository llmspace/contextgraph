# M03-L15: ModelFactory Implementation

```xml
<task_spec id="M03-L15" version="1.0">
<metadata>
  <title>Implement Concrete ModelFactory for All 12 Models</title>
  <status>ready</status>
  <layer>logic</layer>
  <sequence>15</sequence>
  <implements>PRD model instantiation and factory pattern</implements>
  <depends_on>M03-L03, M03-L04, M03-L05, M03-L06, M03-L07, M03-L08, M03-L09, M03-L10, M03-L11, M03-L12, M03-L13, M03-L14, M03-F10</depends_on>
  <estimated_hours>3</estimated_hours>
</metadata>

<context>
Implement the concrete ModelFactory that creates all 12 embedding model types.
This factory is responsible for:
- Instantiating the correct model type based on ModelId
- Applying device placement configuration (CPU/GPU)
- Applying quantization settings
- Estimating memory requirements before loading

The factory serves as the central point for model creation in the registry.
</context>

<definition_of_done>
  <signatures>
```rust
pub struct DefaultModelFactory {
    /// Base directory for model weights
    models_dir: PathBuf,
    /// Device configuration for model placement
    gpu_config: GpuConfig,
    /// Memory estimates per model (pre-computed)
    memory_estimates: HashMap<ModelId, usize>,
}

impl DefaultModelFactory {
    pub fn new(models_dir: impl AsRef<Path>, gpu_config: GpuConfig) -> EmbeddingResult<Self>;

    /// Validate all model directories exist
    pub fn validate_model_paths(&self) -> EmbeddingResult<()>;

    /// Get the model subdirectory for a given model ID
    pub fn model_path(&self, model_id: ModelId) -> PathBuf;

    /// Check if model files exist on disk
    pub fn model_exists(&self, model_id: ModelId) -> bool;
}

impl ModelFactory for DefaultModelFactory {
    fn create_model(
        &self,
        model_id: ModelId,
        config: &SingleModelConfig,
    ) -> EmbeddingResult<Box<dyn EmbeddingModel>>;

    fn supported_models(&self) -> &[ModelId];

    fn estimate_memory(&self, model_id: ModelId) -> usize;
}

/// Model-specific factory functions (internal)
mod creators {
    pub fn create_semantic(path: &Path, config: &SingleModelConfig)
        -> EmbeddingResult<Box<dyn EmbeddingModel>>;
    pub fn create_temporal_recent(config: &SingleModelConfig)
        -> EmbeddingResult<Box<dyn EmbeddingModel>>;
    pub fn create_temporal_periodic(config: &SingleModelConfig)
        -> EmbeddingResult<Box<dyn EmbeddingModel>>;
    pub fn create_temporal_positional(config: &SingleModelConfig)
        -> EmbeddingResult<Box<dyn EmbeddingModel>>;
    pub fn create_causal(path: &Path, config: &SingleModelConfig)
        -> EmbeddingResult<Box<dyn EmbeddingModel>>;
    pub fn create_sparse(path: &Path, config: &SingleModelConfig)
        -> EmbeddingResult<Box<dyn EmbeddingModel>>;
    pub fn create_code(path: &Path, config: &SingleModelConfig)
        -> EmbeddingResult<Box<dyn EmbeddingModel>>;
    pub fn create_graph(path: &Path, config: &SingleModelConfig)
        -> EmbeddingResult<Box<dyn EmbeddingModel>>;
    pub fn create_hdc(config: &SingleModelConfig)
        -> EmbeddingResult<Box<dyn EmbeddingModel>>;
    pub fn create_multimodal(path: &Path, config: &SingleModelConfig)
        -> EmbeddingResult<Box<dyn EmbeddingModel>>;
    pub fn create_entity(path: &Path, config: &SingleModelConfig)
        -> EmbeddingResult<Box<dyn EmbeddingModel>>;
    pub fn create_late_interaction(path: &Path, config: &SingleModelConfig)
        -> EmbeddingResult<Box<dyn EmbeddingModel>>;
}
```
  </signatures>

  <constraints>
    <constraint>Creates correct model type for each ModelId variant</constraint>
    <constraint>Applies DevicePlacement from config (CPU, CUDA(n), Auto)</constraint>
    <constraint>Applies QuantizationMode if specified</constraint>
    <constraint>Custom models (Temporal*, HDC) do not require model paths</constraint>
    <constraint>Pretrained models validate path existence before creation</constraint>
    <constraint>Memory estimates based on model architecture and precision</constraint>
    <constraint>supported_models() returns all 12 ModelId variants</constraint>
    <constraint>Thread-safe factory methods</constraint>
  </constraints>
</definition_of_done>

<files_to_create>
  <file>crates/context-graph-embeddings/src/models/factory.rs</file>
</files_to_create>

<validation_criteria>
  <criterion>cargo check passes</criterion>
  <criterion>cargo test --lib passes</criterion>
  <criterion>DefaultModelFactory::new() validates models_dir exists</criterion>
  <criterion>create_model() returns correct type for each ModelId</criterion>
  <criterion>Custom models create without path validation</criterion>
  <criterion>Pretrained models fail gracefully if path missing</criterion>
  <criterion>estimate_memory() returns reasonable values for all models</criterion>
  <criterion>Device placement is correctly applied</criterion>
  <criterion>supported_models() returns 12 entries</criterion>
</validation_criteria>
</task_spec>
```

---

## Implementation Notes

### Factory Pattern Implementation
```rust
impl ModelFactory for DefaultModelFactory {
    fn create_model(
        &self,
        model_id: ModelId,
        config: &SingleModelConfig,
    ) -> EmbeddingResult<Box<dyn EmbeddingModel>> {
        match model_id {
            // Pretrained models (require model files)
            ModelId::Semantic => {
                let path = self.model_path(model_id);
                creators::create_semantic(&path, config)
            }
            ModelId::Causal => {
                let path = self.model_path(model_id);
                creators::create_causal(&path, config)
            }
            ModelId::Sparse => {
                let path = self.model_path(model_id);
                creators::create_sparse(&path, config)
            }
            ModelId::Code => {
                let path = self.model_path(model_id);
                creators::create_code(&path, config)
            }
            ModelId::Graph => {
                let path = self.model_path(model_id);
                creators::create_graph(&path, config)
            }
            ModelId::Multimodal => {
                let path = self.model_path(model_id);
                creators::create_multimodal(&path, config)
            }
            ModelId::Entity => {
                let path = self.model_path(model_id);
                creators::create_entity(&path, config)
            }
            ModelId::LateInteraction => {
                let path = self.model_path(model_id);
                creators::create_late_interaction(&path, config)
            }

            // Custom models (no pretrained weights)
            ModelId::TemporalRecent => {
                creators::create_temporal_recent(config)
            }
            ModelId::TemporalPeriodic => {
                creators::create_temporal_periodic(config)
            }
            ModelId::TemporalPositional => {
                creators::create_temporal_positional(config)
            }
            ModelId::Hdc => {
                creators::create_hdc(config)
            }
        }
    }

    fn supported_models(&self) -> &[ModelId] {
        ModelId::all()
    }

    fn estimate_memory(&self, model_id: ModelId) -> usize {
        self.memory_estimates.get(&model_id).copied().unwrap_or(0)
    }
}
```

### Model Path Resolution
```rust
impl DefaultModelFactory {
    pub fn model_path(&self, model_id: ModelId) -> PathBuf {
        let subdir = match model_id {
            ModelId::Semantic => "semantic",
            ModelId::Causal => "causal",
            ModelId::Sparse => "sparse",
            ModelId::Code => "code",
            ModelId::Graph => "graph",
            ModelId::Multimodal => "multimodal",
            ModelId::Entity => "entity",
            ModelId::LateInteraction => "late_interaction",
            _ => return self.models_dir.clone(),  // Custom models
        };
        self.models_dir.join(subdir)
    }
}
```

### Memory Estimates (Approximate)
| ModelId | FP32 Memory | FP16 Memory |
|---------|-------------|-------------|
| Semantic (E5-large) | ~1.3 GB | ~650 MB |
| Causal (Longformer) | ~600 MB | ~300 MB |
| Sparse (SPLADE) | ~450 MB | ~225 MB |
| Code (CodeBERT) | ~500 MB | ~250 MB |
| Graph (MiniLM) | ~90 MB | ~45 MB |
| Multimodal (CLIP) | ~1.7 GB | ~850 MB |
| Entity (MiniLM) | ~90 MB | ~45 MB |
| LateInteraction (ColBERT) | ~450 MB | ~225 MB |
| Temporal* (Custom) | ~10 MB | ~10 MB |
| HDC (Custom) | ~50 MB | ~50 MB |

**Total (FP16)**: ~2.7 GB for all 12 models
