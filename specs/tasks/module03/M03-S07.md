<?xml version="1.0" encoding="UTF-8"?>
<task_spec id="M03-S07" version="1.0">
<metadata>
  <title>HotSwap Model Loading</title>
  <status>ready</status>
  <layer>surface</layer>
  <sequence>43</sequence>
  <implements>
    - constitution.yaml: embeddings.runtime.hot_reload
    - PRD: Dynamic model configuration without restart
  </implements>
  <depends_on>
    - M03-L01 (ModelRegistry Core)
    - M03-F12 (SingleModelConfig)
  </depends_on>
  <estimated_hours>3</estimated_hours>
</metadata>

<context>
Implement hot-swap model loading capability that allows models to be replaced
at runtime without stopping the embedding pipeline. This enables:
- Model upgrades without service downtime
- A/B testing of different model versions
- Dynamic resource reallocation based on load patterns
- Recovery from model corruption by swapping in fresh instances

The swap process must be atomic from the perspective of embedding requests,
with proper queuing during the swap window and automatic rollback on failure.
</context>

<definition_of_done>
  <signatures>
    <signature name="swap_model">
impl ModelRegistry {
    /// Atomically swap a loaded model with a new configuration.
    ///
    /// # Arguments
    /// * `model_id` - The model to swap
    /// * `new_config` - Configuration for the new model instance
    ///
    /// # Process
    /// 1. Queue incoming requests for this model
    /// 2. Load new model in background
    /// 3. Validate new model with test input
    /// 4. Atomically swap model reference
    /// 5. Drain queued requests to new model
    /// 6. Unload old model
    ///
    /// # Errors
    /// Returns error if load fails, validation fails, or timeout exceeded
    pub async fn swap_model(
        &amp;self,
        model_id: ModelId,
        new_config: SingleModelConfig,
    ) -> EmbeddingResult&lt;()&gt;;
}
    </signature>
    <signature name="validate_swap">
impl ModelRegistry {
    /// Validate that a new model can replace the existing one.
    ///
    /// Checks:
    /// - Output dimension matches
    /// - Supported input types match
    /// - Test embedding produces valid output
    ///
    /// # Returns
    /// true if the new model is compatible, false otherwise
    pub fn validate_swap(
        &amp;self,
        model_id: ModelId,
        new_model: &amp;dyn EmbeddingModel,
    ) -> bool;
}
    </signature>
    <signature name="swap_status">
impl ModelRegistry {
    /// Get status of ongoing or last swap operation.
    pub fn swap_status(&amp;self, model_id: ModelId) -> Option&lt;SwapStatus&gt;;
}
    </signature>
    <signature name="SwapStatus">
#[derive(Debug, Clone)]
pub struct SwapStatus {
    pub model_id: ModelId,
    pub phase: SwapPhase,
    pub started_at: Instant,
    pub queued_requests: usize,
    pub error: Option&lt;String&gt;,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum SwapPhase {
    Queuing,
    Loading,
    Validating,
    Swapping,
    Draining,
    Complete,
    Failed,
}
    </signature>
  </signatures>

  <constraints>
    <constraint>Queue incoming requests during swap (max 10s queue time)</constraint>
    <constraint>Atomic traffic redirection via Arc::swap</constraint>
    <constraint>Rollback on validation failure - old model remains active</constraint>
    <constraint>Maximum swap time: 60s total, timeout after</constraint>
    <constraint>Swap must not affect other models' operation</constraint>
    <constraint>Memory for both models must fit during transition</constraint>
    <constraint>Emit metrics for swap duration and queued request count</constraint>
  </constraints>
</definition_of_done>

<files_to_create>
  <file>crates/context-graph-embeddings/src/models/hotswap.rs</file>
</files_to_create>

<validation_criteria>
  <criterion>cargo check passes with no errors</criterion>
  <criterion>cargo clippy passes with no warnings</criterion>
  <criterion>swap_model successfully swaps a model without dropping requests</criterion>
  <criterion>validate_swap rejects incompatible model dimensions</criterion>
  <criterion>Swap timeout triggers rollback after 60s</criterion>
  <criterion>Concurrent embedding requests are queued, not rejected</criterion>
  <criterion>Failed validation leaves original model operational</criterion>
</validation_criteria>

<test_cases>
  <test name="test_successful_swap">
    Load semantic model, swap with different config, verify embeddings work
  </test>
  <test name="test_swap_dimension_mismatch">
    Attempt to swap with model having different output dimension, expect rejection
  </test>
  <test name="test_swap_timeout">
    Simulate slow model load exceeding 60s, verify rollback occurs
  </test>
  <test name="test_concurrent_requests_queued">
    Submit requests during swap, verify they complete after swap finishes
  </test>
  <test name="test_swap_memory_check">
    Verify memory check before loading new model prevents OOM
  </test>
</test_cases>

<notes>
Implementation should use Arc&lt;ArcSwap&lt;dyn EmbeddingModel&gt;&gt; pattern for
lock-free atomic swaps. The queuing mechanism should use tokio::sync::broadcast
or similar to hold requests during the swap window.
</notes>
</task_spec>
