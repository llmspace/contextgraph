# Task Specification: M03-L25

```xml
<task_spec id="M03-L25" version="1.0">
<metadata>
  <title>PII Scrubber Implementation</title>
  <status>ready</status>
  <layer>logic</layer>
  <sequence>25</sequence>
  <implements>
    - PRD Section 7.7: Layer 1 pre-processing security
    - Technical Engine Section 0.5: PII scrubbing before embedding
    - Constitution: security.pii_prevention
  </implements>
  <depends_on>
    - M03-F06 (ModelInput)
    - M03-F08 (EmbeddingError)
  </depends_on>
  <estimated_hours>4</estimated_hours>
</metadata>

<context>
Implement a PII Scrubber that runs in Layer 1 (Sensing) BEFORE embeddings are generated.
This prevents sensitive data (API keys, SSNs, credit cards, emails, names, addresses)
from being encoded into the vector space, which is a critical security requirement.

The scrubber operates as a preprocessing step in the EmbeddingPipeline::embed flow,
running before content is passed to the BatchProcessor.

Key responsibilities:
- Regex pattern matching for structured secrets (API keys, tokens, SSNs, credit cards)
- Lightweight NER for names and addresses (using rule-based patterns)
- Redaction or masking of detected PII
- Audit logging of scrubbed content (without revealing actual PII)
- Configurable sensitivity levels (strict, moderate, permissive)
</context>

<definition_of_done>
  <signatures>
```rust
/// PII detection result
#[derive(Debug, Clone)]
pub struct PiiDetection {
    pub category: PiiCategory,
    pub span: (usize, usize),  // byte offsets
    pub confidence: f32,       // 0.0 - 1.0
}

/// Categories of PII that can be detected
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum PiiCategory {
    ApiKey,
    AwsKey,
    JwtToken,
    SocialSecurityNumber,
    CreditCard,
    Email,
    PhoneNumber,
    PersonName,
    Address,
    IpAddress,
    Custom(u32),
}

/// PII scrubbing mode
#[derive(Debug, Clone, Copy, Default)]
pub enum ScrubMode {
    /// Replace PII with [REDACTED]
    #[default]
    Redact,
    /// Replace with category-specific placeholder
    Mask,
    /// Hash the PII value
    Hash,
    /// Remove entirely
    Remove,
}

/// Configuration for PII scrubber
#[derive(Debug, Clone)]
pub struct PiiScrubberConfig {
    pub enabled: bool,
    pub sensitivity: PiiSensitivity,
    pub mode: ScrubMode,
    pub custom_patterns: Vec<(String, PiiCategory)>,
    pub audit_logging: bool,
}

/// Sensitivity levels
#[derive(Debug, Clone, Copy, Default)]
pub enum PiiSensitivity {
    /// Only high-confidence structured patterns (keys, SSN, CC)
    Permissive,
    /// Include emails, phones, IPs
    #[default]
    Moderate,
    /// Include NER for names, addresses
    Strict,
}

pub struct PiiScrubber {
    config: PiiScrubberConfig,
    patterns: CompiledPatterns,
}

impl PiiScrubber {
    /// Create new scrubber with configuration
    pub fn new(config: PiiScrubberConfig) -> EmbeddingResult<Self>;

    /// Detect all PII in content without modifying
    pub fn detect(&self, content: &str) -> Vec<PiiDetection>;

    /// Scrub PII from content, returning cleaned version
    pub fn scrub(&self, content: &str) -> ScrubResult;

    /// Check if content contains any PII
    pub fn contains_pii(&self, content: &str) -> bool;

    /// Process ModelInput, scrubbing text content
    pub fn process_input(&self, input: ModelInput) -> EmbeddingResult<ModelInput>;
}

/// Result of scrubbing operation
#[derive(Debug, Clone)]
pub struct ScrubResult {
    pub cleaned: String,
    pub detections: Vec<PiiDetection>,
    pub was_modified: bool,
}
```
  </signatures>

  <constraints>
    - Must run BEFORE BatchProcessor in pipeline flow
    - Zero-copy where possible (only allocate if PII found)
    - Regex patterns compiled once at construction
    - Thread-safe: scrub operations are stateless
    - No external dependencies for NER (rule-based only)
    - Audit log must not contain actual PII values
    - Processing overhead <1ms for typical content
    - Custom patterns support for project-specific secrets
  </constraints>

  <verification>
    <step>Detects AWS keys: AKIA[0-9A-Z]{16}</step>
    <step>Detects JWT tokens: eyJ[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*</step>
    <step>Detects SSN: \d{3}-\d{2}-\d{4}</step>
    <step>Detects credit cards (Luhn validation)</step>
    <step>Detects email addresses</step>
    <step>Scrub mode correctly replaces/masks/removes PII</step>
    <step>Audit logging records detection without revealing values</step>
    <step>process_input handles Text variant correctly</step>
  </verification>
</definition_of_done>

<files_to_create>
  <file>crates/context-graph-embeddings/src/security/pii_scrubber.rs</file>
  <file>crates/context-graph-embeddings/src/security/patterns.rs</file>
  <file>crates/context-graph-embeddings/src/security/mod.rs</file>
</files_to_create>

<validation_criteria>
  <criterion>cargo check passes</criterion>
  <criterion>cargo test pii passes with 100% pattern coverage</criterion>
  <criterion>No false negatives on test corpus of known PII patterns</criterion>
  <criterion>Processing overhead <1ms on 10KB content</criterion>
  <criterion>Audit log entries contain category and position, not values</criterion>
</validation_criteria>
</task_spec>
```

## Implementation Notes

### Pattern Examples

```rust
// API Key patterns
const AWS_KEY: &str = r"AKIA[0-9A-Z]{16}";
const GITHUB_TOKEN: &str = r"ghp_[A-Za-z0-9]{36}";
const ANTHROPIC_KEY: &str = r"sk-ant-[A-Za-z0-9-]{93}";
const OPENAI_KEY: &str = r"sk-[A-Za-z0-9]{48}";

// Structured data patterns
const SSN: &str = r"\b\d{3}-\d{2}-\d{4}\b";
const CREDIT_CARD: &str = r"\b\d{4}[\s-]?\d{4}[\s-]?\d{4}[\s-]?\d{4}\b";
const EMAIL: &str = r"\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b";
```

### Integration Point

The scrubber integrates into `EmbeddingPipeline::embed()`:

```rust
pub async fn embed(&self, content: &str) -> EmbeddingResult<FusedEmbedding> {
    // Step 0: PII Scrubbing (Layer 1 pre-processing)
    let scrubbed = self.pii_scrubber.scrub(content);
    if scrubbed.was_modified {
        log::info!("Scrubbed {} PII instances", scrubbed.detections.len());
    }

    // Step 1: Cache lookup (with original hash for cache key)
    let cache_key = self.hash_content(&scrubbed.cleaned);
    // ... rest of pipeline
}
```

---
*Task ID: M03-L25*
*Layer: Logic*
*Module: 03 - 12-Model Embedding Pipeline*
