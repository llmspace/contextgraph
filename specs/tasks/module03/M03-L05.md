# M03-L05: Temporal-Periodic Model (E3 - Fourier Basis)

## Task Metadata
| Field | Value |
|-------|-------|
| **ID** | M03-L05 |
| **Layer** | Logic |
| **Status** | Ready |
| **Depends On** | M03-F09 (EmbeddingModel trait), M03-F16 (module structure), M03-L04 (temporal_recent pattern) |
| **Implements** | PRD E3: Temporal-Periodic embedding, 512D output, custom computed |
| **Constitution Ref** | embeddings.models.E3_Temporal_Periodic |
| **Estimated Hours** | 3 |

---

## Critical Context for AI Agent

### What This Task Is
Implement the **TemporalPeriodicModel** - a custom embedding model (E3) that produces 512-dimensional vectors encoding cyclical time patterns using Fourier basis functions. This model captures periodic patterns like hour-of-day, day-of-week, and month-of-year cycles.

### Key Differences from TemporalRecent (M03-L04)
| Aspect | TemporalRecent (E2) | TemporalPeriodic (E3) |
|--------|---------------------|----------------------|
| Purpose | Recency (how recently?) | Periodicity (what cycle?) |
| Math | Exponential decay | Fourier sin/cos |
| Output | Decay values | Sin/cos of phase angles |
| Time scales | hour/day/week/month | hour/day/week/month/year |

### Key Facts
- **NO pretrained weights** - pure computation based on timestamps
- **512D output** - matches `ModelId::TemporalPeriodic.dimension()` in `crates/context-graph-embeddings/src/types/model_id.rs`
- **Custom model** - `ModelId::TemporalPeriodic.is_pretrained()` returns `false`
- **Always "initialized"** - no weight files needed, `is_initialized()` returns `true` after construction
- **Latency budget**: <2ms per constitution.yaml

### Where Files Go
```
crates/context-graph-embeddings/src/models/
├── mod.rs                      # UPDATE: Add TemporalPeriodicModel exports
├── custom/
│   ├── mod.rs                  # UPDATE: Add temporal_periodic module
│   ├── temporal_recent.rs      # EXISTING: E2 implementation (REFERENCE)
│   └── temporal_periodic.rs    # NEW: E3 implementation
```

---

## Existing Codebase Patterns to Follow

### 1. EmbeddingModel Trait (MUST implement exactly)
Location: `crates/context-graph-embeddings/src/traits/embedding_model.rs`

```rust
#[async_trait]
pub trait EmbeddingModel: Send + Sync {
    // REQUIRED METHODS (4 total)
    fn model_id(&self) -> ModelId;
    fn supported_input_types(&self) -> &[InputType];
    async fn embed(&self, input: &ModelInput) -> EmbeddingResult<ModelEmbedding>;
    fn is_initialized(&self) -> bool;

    // DEFAULT IMPLEMENTATIONS PROVIDED (DO NOT override):
    fn supports_input_type(&self, input_type: InputType) -> bool;
    fn dimension(&self) -> usize;        // delegates to model_id().dimension()
    fn projected_dimension(&self) -> usize;
    fn latency_budget_ms(&self) -> u32;
    fn max_tokens(&self) -> usize;
    fn is_pretrained(&self) -> bool;
    fn validate_input(&self, input: &ModelInput) -> EmbeddingResult<()>;
}
```

**CRITICAL**: The trait has EXACTLY 4 required methods. Use `validate_input()` from default impl.

### 2. Error Types to Use
Location: `crates/context-graph-embeddings/src/error.rs`

Key errors:
- `EmbeddingError::UnsupportedModality { model_id, input_type }` - for non-Text inputs
- `EmbeddingError::ConfigError { message }` - for invalid configuration
- `EmbeddingError::InternalError { message }` - for unexpected failures

### 3. ModelInput Structure
Location: `crates/context-graph-embeddings/src/types/input.rs`

```rust
pub enum ModelInput {
    Text { content: String, instruction: Option<String> },
    Code { content: String, language: String },
    Image { data: Vec<u8>, format: ImageFormat },
    Audio { data: Vec<u8>, format: AudioFormat, sample_rate: u32 },
}
```

**Timestamp extraction**: Parse from `instruction` field:
- ISO 8601: `"timestamp:2024-01-15T10:30:00Z"`
- Unix epoch: `"epoch:1705315800"`
- Fallback to `chrono::Utc::now()` if no timestamp

### 4. ModelEmbedding Output
Location: `crates/context-graph-embeddings/src/types/embedding.rs`

```rust
pub struct ModelEmbedding {
    pub model_id: ModelId,
    pub vector: Vec<f32>,
    pub latency_us: u64,
    pub attention_weights: Option<Vec<f32>>,
    pub is_projected: bool,
}

impl ModelEmbedding {
    pub fn new(model_id: ModelId, vector: Vec<f32>, latency_us: u64) -> Self;
    pub fn validate(&self) -> EmbeddingResult<()>;  // checks dimension, NaN, Inf
}
```

### 5. Reference Implementation Pattern
Follow `TemporalRecentModel` in `crates/context-graph-embeddings/src/models/custom/temporal_recent.rs`:
- Uses `AtomicBool` for thread-safe initialized state
- Uses `std::time::Instant` to track latency
- Parses timestamps from instruction field
- Returns deterministic embeddings based on timestamp
- Validates input type before processing
- L2 normalizes output vector

---

## Exact Implementation Requirements

### TemporalPeriodicModel Structure

```rust
use chrono::{DateTime, Utc};
use std::sync::atomic::{AtomicBool, Ordering};
use std::time::Duration;
use async_trait::async_trait;

/// Native dimension for TemporalPeriodic model (E3).
pub const TEMPORAL_PERIODIC_DIMENSION: usize = 512;

/// Standard periods for temporal encoding (in seconds).
pub mod periods {
    /// 1 hour = 3600 seconds
    pub const HOUR: u64 = 3600;
    /// 1 day = 86400 seconds
    pub const DAY: u64 = 86400;
    /// 1 week = 604800 seconds
    pub const WEEK: u64 = 604800;
    /// 1 month = 2592000 seconds (~30 days)
    pub const MONTH: u64 = 2592000;
    /// 1 year = 31536000 seconds (~365 days)
    pub const YEAR: u64 = 31536000;
}

/// Default periods for encoding: hour, day, week, month, year
pub const DEFAULT_PERIODS: [u64; 5] = [
    periods::HOUR,
    periods::DAY,
    periods::WEEK,
    periods::MONTH,
    periods::YEAR,
];

/// Number of frequency harmonics per period (5 periods x ~102 features = 510, pad to 512)
const HARMONICS_PER_PERIOD: usize = 51;

/// Features per period including sin and cos (51 harmonics x 2 = 102 per period)
const FEATURES_PER_PERIOD: usize = 102;

/// Temporal-Periodic embedding model (E3).
///
/// Encodes cyclical time patterns using Fourier basis functions.
/// This is a custom model with no pretrained weights - it computes embeddings
/// from timestamps using sin/cos of phase angles.
///
/// # Algorithm
///
/// For each period P (hour, day, week, month, year):
///   - Convert timestamp to seconds since Unix epoch
///   - Compute phase: θ = 2π × (timestamp_secs mod P) / P
///   - Generate harmonics: sin(n×θ), cos(n×θ) for n = 1..51
///
/// This captures:
///   - Hour-of-day patterns (morning vs evening)
///   - Day-of-week patterns (weekday vs weekend)
///   - Month-of-year patterns (seasonal effects)
///
/// # Construction
///
/// ```rust,ignore
/// use context_graph_embeddings::models::TemporalPeriodicModel;
///
/// // Default periods (hour, day, week, month, year)
/// let model = TemporalPeriodicModel::new();
///
/// // Custom periods
/// let model = TemporalPeriodicModel::with_periods(vec![3600, 86400])?;
/// ```
pub struct TemporalPeriodicModel {
    /// Periods in seconds for Fourier encoding.
    periods: Vec<u64>,

    /// Number of harmonics per period.
    num_harmonics: usize,

    /// Always true for custom models (no weights to load).
    initialized: AtomicBool,
}
```

### Core Algorithm

The Fourier embedding encodes cyclical patterns at multiple time scales:

```rust
fn compute_fourier_embedding(&self, timestamp: DateTime<Utc>) -> Vec<f32> {
    let timestamp_secs = timestamp.timestamp() as f64;
    let mut vector = Vec::with_capacity(TEMPORAL_PERIODIC_DIMENSION);

    for &period in &self.periods {
        let period_f64 = period as f64;

        // Phase angle in range [0, 2π)
        let phase = 2.0 * std::f64::consts::PI * (timestamp_secs % period_f64) / period_f64;

        // Generate harmonics: sin(n×θ), cos(n×θ) for n = 1..num_harmonics
        for n in 1..=self.num_harmonics {
            let n_f64 = n as f64;
            let sin_val = (n_f64 * phase).sin() as f32;
            let cos_val = (n_f64 * phase).cos() as f32;
            vector.push(sin_val);
            vector.push(cos_val);
        }
    }

    // Pad to exactly 512 dimensions if needed
    while vector.len() < TEMPORAL_PERIODIC_DIMENSION {
        vector.push(0.0);
    }

    // L2 normalize
    let norm: f32 = vector.iter().map(|x| x * x).sum::<f32>().sqrt();
    if norm > f32::EPSILON {
        for v in &mut vector {
            *v /= norm;
        }
    }

    vector
}
```

### Timestamp Extraction (Reuse from TemporalRecent)

```rust
fn extract_timestamp(&self, input: &ModelInput) -> DateTime<Utc> {
    match input {
        ModelInput::Text { instruction, .. } => instruction
            .as_ref()
            .and_then(|inst| Self::parse_timestamp(inst))
            .unwrap_or_else(Utc::now),
        _ => Utc::now(),
    }
}

fn parse_timestamp(instruction: &str) -> Option<DateTime<Utc>> {
    // Try ISO 8601 format: "timestamp:2024-01-15T10:30:00Z"
    if let Some(ts_str) = instruction.strip_prefix("timestamp:") {
        if let Ok(dt) = DateTime::parse_from_rfc3339(ts_str.trim()) {
            return Some(dt.with_timezone(&Utc));
        }
    }

    // Try Unix epoch: "epoch:1705315800"
    if let Some(epoch_str) = instruction.strip_prefix("epoch:") {
        if let Ok(secs) = epoch_str.trim().parse::<i64>() {
            return DateTime::from_timestamp(secs, 0);
        }
    }

    None
}
```

---

## Files to Create/Modify

### 1. CREATE: `crates/context-graph-embeddings/src/models/custom/temporal_periodic.rs`

Full implementation with:
- `TemporalPeriodicModel` struct with periods and num_harmonics
- `new()` - default constructor with 5 periods
- `with_periods(Vec<u64>)` - custom periods constructor
- `compute_fourier_embedding()` - core algorithm
- `extract_timestamp()` and `parse_timestamp()` - timestamp parsing
- `EmbeddingModel` trait implementation
- Comprehensive tests (30+ tests) covering:
  - Construction tests
  - Trait implementation tests
  - Embedding output tests
  - Fourier property tests (same time-of-day similarity)
  - Determinism tests
  - Edge case tests (all 3 mandatory)
  - Source of truth verification test
  - Evidence of success test

### 2. UPDATE: `crates/context-graph-embeddings/src/models/custom/mod.rs`

Add after line 10:
```rust
mod temporal_periodic;
```

Add to exports after line 12:
```rust
pub use temporal_periodic::{
    TemporalPeriodicModel,
    TEMPORAL_PERIODIC_DIMENSION,
    DEFAULT_PERIODS,
    periods,
};
```

### 3. UPDATE: `crates/context-graph-embeddings/src/models/mod.rs`

Add to exports after line 51:
```rust
pub use custom::{
    TemporalPeriodicModel,
    TEMPORAL_PERIODIC_DIMENSION,
    DEFAULT_PERIODS,
    periods,
};
```

---

## Verification Requirements

### Definition of Done Checklist

- [ ] `cargo check -p context-graph-embeddings` passes
- [ ] `cargo test -p context-graph-embeddings` passes with all new tests
- [ ] `cargo clippy -p context-graph-embeddings -- -D warnings` passes
- [ ] TemporalPeriodicModel implements EmbeddingModel trait
- [ ] `model.model_id()` returns `ModelId::TemporalPeriodic`
- [ ] `model.dimension()` returns 512 (via default impl)
- [ ] `model.is_initialized()` returns true after construction
- [ ] `model.is_pretrained()` returns false (via default impl)
- [ ] embed() returns exactly 512D vector
- [ ] Vector is L2 normalized (norm within 0.001 of 1.0)
- [ ] No NaN or Inf values in output
- [ ] Same time-of-day on different days produces similar embeddings
- [ ] Same day-of-week on different weeks produces similar embeddings
- [ ] Output values in range [-1, 1] for sin/cos components (before normalization)
- [ ] Same timestamp produces identical embedding (deterministic)
- [ ] Latency < 2ms (pure computation, no I/O)

---

## Full State Verification Protocol

### 1. Source of Truth
The embedding output vector stored in `ModelEmbedding.vector`.

### 2. Execute & Inspect Test

```rust
#[tokio::test]
async fn test_source_of_truth_verification() {
    let model = TemporalPeriodicModel::new();
    let input = ModelInput::text_with_instruction(
        "test content",
        "timestamp:2024-01-15T10:30:00Z"
    ).expect("Failed to create input");

    // Execute
    let embedding = model.embed(&input).await.expect("Embed should succeed");

    // INSPECT SOURCE OF TRUTH
    println!("=== SOURCE OF TRUTH VERIFICATION ===");
    println!("model_id: {:?}", embedding.model_id);
    println!("vector.len(): {}", embedding.vector.len());
    println!("vector[0..10]: {:?}", &embedding.vector[0..10]);
    println!("latency_us: {}", embedding.latency_us);

    let norm: f32 = embedding.vector.iter().map(|x| x * x).sum::<f32>().sqrt();
    println!("L2 norm: {}", norm);

    let has_nan = embedding.vector.iter().any(|x| x.is_nan());
    let has_inf = embedding.vector.iter().any(|x| x.is_infinite());
    println!("has_nan: {}, has_inf: {}", has_nan, has_inf);

    // Check sin/cos range before normalization
    let raw_range_ok = embedding.vector.iter().all(|&x| x >= -1.0 && x <= 1.0);
    println!("all values in [-1, 1]: {}", raw_range_ok);

    // VERIFY
    assert_eq!(embedding.model_id, ModelId::TemporalPeriodic);
    assert_eq!(embedding.vector.len(), 512);
    assert!((norm - 1.0).abs() < 0.001);
    assert!(!has_nan && !has_inf);
}
```

### 3. Boundary & Edge Case Audit (MANDATORY)

#### Edge Case 1: Timestamps exactly 24 hours apart (same time-of-day)
```rust
#[tokio::test]
async fn test_edge_case_1_same_time_different_days() {
    let model = TemporalPeriodicModel::new();

    println!("=== EDGE CASE 1: Same Time Different Days ===");

    // Same time on consecutive days
    let day1 = "timestamp:2024-01-15T10:30:00Z";
    let day2 = "timestamp:2024-01-16T10:30:00Z";

    println!("BEFORE: day1 = {}", day1);
    println!("BEFORE: day2 = {}", day2);

    let input1 = ModelInput::text_with_instruction("content", day1).unwrap();
    let input2 = ModelInput::text_with_instruction("content", day2).unwrap();

    let emb1 = model.embed(&input1).await.expect("Embed day1");
    let emb2 = model.embed(&input2).await.expect("Embed day2");

    // Hour-of-day features should be similar
    // First 102 features are hour encoding
    let hour_features_1: Vec<f32> = emb1.vector[0..102].to_vec();
    let hour_features_2: Vec<f32> = emb2.vector[0..102].to_vec();

    let cosine_sim: f32 = hour_features_1.iter()
        .zip(hour_features_2.iter())
        .map(|(a, b)| a * b)
        .sum();

    println!("AFTER: hour features cosine similarity = {}", cosine_sim);

    // Day-of-week features should be different (Mon vs Tue)
    let day_features_1: Vec<f32> = emb1.vector[102..204].to_vec();
    let day_features_2: Vec<f32> = emb2.vector[102..204].to_vec();

    let day_sim: f32 = day_features_1.iter()
        .zip(day_features_2.iter())
        .map(|(a, b)| a * b)
        .sum();

    println!("AFTER: day features cosine similarity = {}", day_sim);

    assert_eq!(emb1.vector.len(), 512);
    assert_eq!(emb2.vector.len(), 512);
    // Hour features should be identical (same time of day)
    assert!(cosine_sim > 0.99, "Same time-of-day should have similar hour features");
}
```

#### Edge Case 2: Same day-of-week different weeks
```rust
#[tokio::test]
async fn test_edge_case_2_same_weekday_different_weeks() {
    let model = TemporalPeriodicModel::new();

    println!("=== EDGE CASE 2: Same Weekday Different Weeks ===");

    // Both are Mondays (7 days apart)
    let week1 = "timestamp:2024-01-15T10:30:00Z";  // Monday
    let week2 = "timestamp:2024-01-22T10:30:00Z";  // Monday next week

    println!("BEFORE: week1 (Mon) = {}", week1);
    println!("BEFORE: week2 (Mon) = {}", week2);

    let input1 = ModelInput::text_with_instruction("content", week1).unwrap();
    let input2 = ModelInput::text_with_instruction("content", week2).unwrap();

    let emb1 = model.embed(&input1).await.expect("Embed week1");
    let emb2 = model.embed(&input2).await.expect("Embed week2");

    // Week features (positions 204-306) should be similar
    let week_features_1: Vec<f32> = emb1.vector[204..306].to_vec();
    let week_features_2: Vec<f32> = emb2.vector[204..306].to_vec();

    let week_sim: f32 = week_features_1.iter()
        .zip(week_features_2.iter())
        .map(|(a, b)| a * b)
        .sum();

    println!("AFTER: week features cosine similarity = {}", week_sim);

    assert!(week_sim > 0.99, "Same day-of-week should have similar week features");
}
```

#### Edge Case 3: No timestamp (fallback to current time)
```rust
#[tokio::test]
async fn test_edge_case_3_no_timestamp_fallback() {
    let model = TemporalPeriodicModel::new();

    println!("=== EDGE CASE 3: No Timestamp (Fallback) ===");
    println!("BEFORE: input has no timestamp instruction");

    let input = ModelInput::text("content without timestamp").expect("Failed to create input");

    let embedding = model.embed(&input).await.expect("Embed should succeed");

    println!("AFTER: vector[0..5] = {:?}", &embedding.vector[0..5]);
    println!("AFTER: Should use current time as fallback");

    assert_eq!(embedding.vector.len(), 512);
    assert!(embedding.vector.iter().all(|x| x.is_finite()));
}
```

### 4. Evidence of Success Log

```rust
#[tokio::test]
async fn test_evidence_of_success() {
    println!("\n========================================");
    println!("M03-L05 EVIDENCE OF SUCCESS");
    println!("========================================\n");

    let model = TemporalPeriodicModel::new();

    // Test 1: Model metadata
    println!("1. MODEL METADATA:");
    println!("   model_id = {:?}", model.model_id());
    println!("   dimension = {}", model.dimension());
    println!("   is_initialized = {}", model.is_initialized());
    println!("   is_pretrained = {}", model.is_pretrained());
    println!("   latency_budget_ms = {}", model.latency_budget_ms());
    println!("   periods = {:?}", model.periods);

    // Test 2: Embed and verify output
    let input = ModelInput::text_with_instruction(
        "test",
        "timestamp:2024-01-15T10:30:00Z"
    ).expect("Failed to create input");

    let start = std::time::Instant::now();
    let embedding = model.embed(&input).await.expect("Embed should succeed");
    let elapsed = start.elapsed();

    println!("\n2. EMBEDDING OUTPUT:");
    println!("   vector length = {}", embedding.vector.len());
    println!("   latency = {:?}", elapsed);
    println!("   first 10 values = {:?}", &embedding.vector[0..10]);

    let norm: f32 = embedding.vector.iter().map(|x| x * x).sum::<f32>().sqrt();
    println!("   L2 norm = {}", norm);

    // Test 3: Periodicity verification
    println!("\n3. PERIODICITY VERIFICATION:");

    // Same time-of-day check
    let day1_input = ModelInput::text_with_instruction(
        "test", "timestamp:2024-01-15T10:30:00Z"
    ).unwrap();
    let day2_input = ModelInput::text_with_instruction(
        "test", "timestamp:2024-01-16T10:30:00Z"
    ).unwrap();

    let day1_emb = model.embed(&day1_input).await.unwrap();
    let day2_emb = model.embed(&day2_input).await.unwrap();

    let hour_sim: f32 = day1_emb.vector[0..102].iter()
        .zip(day2_emb.vector[0..102].iter())
        .map(|(a, b)| a * b)
        .sum();

    println!("   same time-of-day similarity (hours 0-102) = {}", hour_sim);

    println!("\n========================================");
    println!("ALL CHECKS PASSED");
    println!("========================================\n");

    assert!(elapsed.as_millis() < 2, "Latency exceeded 2ms budget");
    assert_eq!(embedding.vector.len(), 512);
    assert!((norm - 1.0).abs() < 0.001);
}
```

---

## Anti-Patterns to Avoid (from constitution.yaml)

- **AP-001**: Never use `unwrap()` in prod - use `expect()` with context or `?`
- **AP-003**: No magic numbers - define constants for periods and harmonics
- **AP-009**: NaN/Infinity in output - normalize safely with epsilon check
- **AP-015**: GPU alloc without pool - this is CPU-only, no GPU

---

## Testing Commands

```bash
# Build check
cargo check -p context-graph-embeddings

# Run all tests
cargo test -p context-graph-embeddings

# Run only TemporalPeriodicModel tests
cargo test -p context-graph-embeddings temporal_periodic

# Run with output for verification
cargo test -p context-graph-embeddings test_evidence_of_success -- --nocapture

# Run edge case tests with output
cargo test -p context-graph-embeddings test_edge_case -- --nocapture

# Lint check
cargo clippy -p context-graph-embeddings -- -D warnings
```

---

## Manual Output Verification (MANDATORY)

After implementing, you MUST manually verify outputs exist:

1. **Check file creation**:
   ```bash
   ls -la crates/context-graph-embeddings/src/models/custom/
   # Expected: mod.rs, temporal_recent.rs, temporal_periodic.rs
   ```

2. **Check module exports**:
   ```bash
   grep -n "temporal_periodic" crates/context-graph-embeddings/src/models/custom/mod.rs
   # Expected: lines showing mod and pub use
   ```

3. **Check parent exports**:
   ```bash
   grep -n "TemporalPeriodicModel" crates/context-graph-embeddings/src/models/mod.rs
   # Expected: line showing pub use
   ```

4. **Run tests with output**:
   ```bash
   cargo test -p context-graph-embeddings test_evidence_of_success -- --nocapture 2>&1 | grep -A 50 "M03-L05 EVIDENCE"
   # Expected: See "ALL CHECKS PASSED" in output
   ```

5. **Verify specific test output**:
   ```bash
   cargo test -p context-graph-embeddings temporal_periodic::tests::test_source_of_truth -- --nocapture
   # Expected: SOURCE OF TRUTH VERIFICATION with all assertions passing
   ```

6. **Verify no regressions**:
   ```bash
   cargo test -p context-graph-embeddings 2>&1 | tail -5
   # Expected: "test result: ok. N passed; 0 failed"
   ```

7. **Verify periodicity math**:
   ```bash
   cargo test -p context-graph-embeddings test_edge_case_1 -- --nocapture 2>&1 | grep "cosine similarity"
   # Expected: hour features similarity > 0.99
   ```

---

## Final Verification Checklist (Sherlock Protocol)

After implementation is complete, the `sherlock-holmes` subagent MUST verify:

| # | Check | How to Verify | Expected Result |
|---|-------|---------------|-----------------|
| 1 | File Existence | `ls crates/context-graph-embeddings/src/models/custom/temporal_periodic.rs` | File exists |
| 2 | Module Export | `grep "pub mod temporal_periodic" .../custom/mod.rs` | Line found |
| 3 | Trait Implementation | `grep "impl EmbeddingModel for TemporalPeriodicModel"` | Line found |
| 4 | Dimension Accuracy | `cargo test test_embed_returns_512d` | Test passes |
| 5 | Normalization | `cargo test test_embed_l2_normalized` | Test passes, norm = 1.0 |
| 6 | Determinism | `cargo test test_deterministic` | Same input = same output |
| 7 | Periodicity - Hour | `cargo test test_edge_case_1` | Cosine sim > 0.99 |
| 8 | Periodicity - Week | `cargo test test_edge_case_2` | Cosine sim > 0.99 |
| 9 | Edge Case - No Timestamp | `cargo test test_edge_case_3` | Test passes |
| 10 | Performance | `cargo test test_embed_latency_under_2ms` | Latency < 2ms |
| 11 | No NaN/Inf | `cargo test test_embed_no_nan test_embed_no_inf` | Both pass |
| 12 | No Regressions | `cargo test -p context-graph-embeddings` | All tests pass |
| 13 | Code Quality | `cargo clippy -p context-graph-embeddings -- -D warnings` | Zero warnings |

**The task is NOT complete until sherlock-holmes verifies all 13 checks pass.**

---

## Sherlock Verification Template

After implementation, add this section with verification results:

```markdown
## Sherlock Verification (DATE)

**VERDICT: [VERIFIED/FAILED] - [X/13] CHECKS PASSED**

| # | Check | Status | Evidence |
|---|-------|--------|----------|
| 1 | File Existence | [PASS/FAIL] | [evidence] |
| 2 | Module Export | [PASS/FAIL] | [evidence] |
| 3 | Trait Implementation | [PASS/FAIL] | [evidence] |
| 4 | Dimension Accuracy | [PASS/FAIL] | [evidence] |
| 5 | Normalization | [PASS/FAIL] | [evidence] |
| 6 | Determinism | [PASS/FAIL] | [evidence] |
| 7 | Periodicity - Hour | [PASS/FAIL] | [evidence] |
| 8 | Periodicity - Week | [PASS/FAIL] | [evidence] |
| 9 | Edge Case - No Timestamp | [PASS/FAIL] | [evidence] |
| 10 | Performance | [PASS/FAIL] | [evidence] |
| 11 | No NaN/Inf | [PASS/FAIL] | [evidence] |
| 12 | No Regressions | [PASS/FAIL] | [evidence] |
| 13 | Code Quality | [PASS/FAIL] | [evidence] |

**Files Created:**
- [list]

**Files Modified:**
- [list]
```
