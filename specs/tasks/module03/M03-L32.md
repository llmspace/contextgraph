# Task Specification: M03-L32

```xml
<task_spec id="M03-L32" version="1.0">
<metadata>
  <title>HDC Base-Vector Persistence</title>
  <status>ready</status>
  <layer>logic</layer>
  <sequence>32</sequence>
  <implements>
    - PRD Section 7.3: E9 HDC symbolic embedding consistency
    - Constitution: reliability.embedding_stability
    - Technical Engine: Long-term vector space integrity
  </implements>
  <depends_on>
    - M03-L11 (HDC Custom Model E9)
    - M03-F01 (ModelId)
    - M03-S13 (ModelArtifactManager)
  </depends_on>
  <estimated_hours>3</estimated_hours>
</metadata>

<context>
Implement persistence layer for HDC (Hyperdimensional Computing) base vectors and position
vectors. In M03-L11, random base vectors are initialized using a seed. If these vectors
are not persisted and reloaded identically on every system restart, ALL previously stored
HDC-based embeddings in the database (Module 4) become semantically invalid and unsearchable.

The HDC model's symbolic space is defined by:
- base_vectors: One 1024D hypervector per unique symbol/token in vocabulary
- position_vectors: One 1024D hypervector per position (for sequence encoding)

These vectors MUST remain identical across the system's entire lifetime. Any regeneration
with a different seed or order would create an incompatible vector space.

Key responsibilities:
- Serialize HDC base_vectors and position_vectors to disk
- Associate persisted vectors with model version identifier
- Verify vector integrity on load (checksum validation)
- Support migration when vocabulary expands (append-only growth)
- Integrate with ModelArtifactManager for lifecycle management
</context>

<definition_of_done>
  <signatures>
```rust
use std::path::PathBuf;

/// HDC vector space persistence configuration
#[derive(Debug, Clone)]
pub struct HdcPersistenceConfig {
    pub storage_path: PathBuf,
    pub model_version: String,
    pub checksum_algorithm: ChecksumAlgorithm,
    pub compression: Option<CompressionType>,
}

#[derive(Debug, Clone, Copy, Default)]
pub enum ChecksumAlgorithm {
    #[default]
    Xxh3,
    Sha256,
}

#[derive(Debug, Clone, Copy)]
pub enum CompressionType {
    Zstd { level: i32 },
    Lz4,
}

/// Persisted HDC vector space
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct HdcVectorSpace {
    pub version: String,
    pub seed: u64,
    pub dimension: usize,
    pub base_vectors: Vec<Vec<f32>>,      // [vocab_size, dimension]
    pub position_vectors: Vec<Vec<f32>>,  // [max_positions, dimension]
    pub checksum: u64,
    pub created_at: u64,                  // Unix timestamp
}

/// HDC vector persistence manager
pub struct HdcVectorPersistence {
    config: HdcPersistenceConfig,
}

impl HdcVectorPersistence {
    /// Create new persistence manager
    pub fn new(config: HdcPersistenceConfig) -> Self;

    /// Save HDC vector space to disk
    pub async fn save(&self, space: &HdcVectorSpace) -> EmbeddingResult<PathBuf>;

    /// Load HDC vector space from disk
    pub async fn load(&self) -> EmbeddingResult<HdcVectorSpace>;

    /// Check if persisted vectors exist for current version
    pub fn exists(&self) -> bool;

    /// Verify checksum of persisted vectors
    pub async fn verify(&self) -> EmbeddingResult<bool>;

    /// Get path where vectors are/would be stored
    pub fn storage_path(&self) -> PathBuf;

    /// Migrate vector space (append new vectors for vocabulary expansion)
    pub async fn migrate(
        &self,
        existing: &HdcVectorSpace,
        new_vocab_size: usize,
        new_max_positions: usize,
        seed: u64,
    ) -> EmbeddingResult<HdcVectorSpace>;

    /// Compute checksum of vector space
    pub fn compute_checksum(space: &HdcVectorSpace) -> u64;
}

/// Integration with HDC model initialization
impl HdcModel {
    /// Initialize HDC model with persistence
    pub async fn new_with_persistence(
        config: HdcModelConfig,
        persistence: HdcVectorPersistence,
    ) -> EmbeddingResult<Self> {
        let space = if persistence.exists() {
            // Load existing vectors
            let loaded = persistence.load().await?;
            if !persistence.verify().await? {
                return Err(EmbeddingError::CorruptedVectors {
                    model: ModelId::Hdc,
                    reason: "Checksum mismatch".into(),
                });
            }
            loaded
        } else {
            // Generate and persist new vectors
            let space = Self::generate_vector_space(config.seed, config.vocab_size)?;
            persistence.save(&space).await?;
            space
        };

        Self::from_vector_space(space, config)
    }
}
```
  </signatures>

  <constraints>
    - Vectors MUST be byte-identical across loads (deterministic serialization)
    - Use little-endian f32 format for cross-platform compatibility
    - Checksum computed over raw vector bytes (not serialized format)
    - Compression optional but must not affect decompressed output
    - File format: header (version, dims, counts) + raw vectors + checksum
    - Migration MUST preserve existing vectors (append-only)
    - Load time <100ms for typical vocabulary (50k tokens)
    - Storage path under ModelArtifactManager cache directory
    - Version string format: "hdc-v{major}.{minor}-{seed}"
  </constraints>

  <verification>
    <step>save() creates file with correct format and checksum</step>
    <step>load() returns byte-identical vectors to what was saved</step>
    <step>verify() detects corrupted files (flip one bit, expect failure)</step>
    <step>exists() correctly identifies presence of persisted vectors</step>
    <step>migrate() preserves original vectors and appends new ones</step>
    <step>HdcModel::new_with_persistence loads existing on second init</step>
    <step>Cross-process: two processes loading same file get identical vectors</step>
    <step>Embeddings from loaded model match embeddings from original session</step>
  </verification>
</definition_of_done>

<files_to_create>
  <file>crates/context-graph-embeddings/src/models/hdc/persistence.rs</file>
</files_to_create>

<validation_criteria>
  <criterion>cargo check passes</criterion>
  <criterion>cargo test hdc::persistence passes</criterion>
  <criterion>Round-trip save/load produces identical vectors</criterion>
  <criterion>Checksum validation catches single-bit corruption</criterion>
  <criterion>Load performance <100ms for 50k vocabulary</criterion>
  <criterion>Integration test: embed same text before/after restart, vectors match</criterion>
</validation_criteria>
</task_spec>
```

## Implementation Notes

### File Format (Binary)

```
+------------------+
| HEADER (64 bytes)|
+------------------+
| Magic: "HDCV" (4)|
| Version: u32     |
| Seed: u64        |
| Dimension: u32   |
| VocabSize: u32   |
| MaxPositions: u32|
| Checksum: u64    |
| Timestamp: u64   |
| Reserved: 20B    |
+------------------+
| BASE VECTORS     |
| [vocab × dim×f32]|
+------------------+
| POSITION VECTORS |
| [pos × dim × f32]|
+------------------+
```

### Checksum Computation

```rust
impl HdcVectorPersistence {
    pub fn compute_checksum(space: &HdcVectorSpace) -> u64 {
        use xxhash_rust::xxh3::xxh3_64;

        let mut hasher_input = Vec::new();

        // Hash base vectors
        for vec in &space.base_vectors {
            for val in vec {
                hasher_input.extend_from_slice(&val.to_le_bytes());
            }
        }

        // Hash position vectors
        for vec in &space.position_vectors {
            for val in vec {
                hasher_input.extend_from_slice(&val.to_le_bytes());
            }
        }

        xxh3_64(&hasher_input)
    }
}
```

### Integration with ModelArtifactManager

```rust
impl ModelArtifactManager {
    pub fn hdc_persistence(&self) -> HdcVectorPersistence {
        HdcVectorPersistence::new(HdcPersistenceConfig {
            storage_path: self.cache_dir.join("hdc_vectors.bin"),
            model_version: format!("hdc-v1.0-{}", self.hdc_seed),
            checksum_algorithm: ChecksumAlgorithm::Xxh3,
            compression: None, // Raw for speed
        })
    }
}
```

### Stability Guarantee Example

```rust
#[test]
fn test_embedding_stability_across_restarts() {
    let test_text = "Python code for a loop";

    // Session 1: Create model, embed, save vectors
    let model1 = HdcModel::new_with_persistence(config.clone(), persistence.clone()).await?;
    let emb1 = model1.embed(test_text).await?;
    drop(model1);

    // Session 2: Load model from persisted vectors, embed same text
    let model2 = HdcModel::new_with_persistence(config, persistence).await?;
    let emb2 = model2.embed(test_text).await?;

    // Embeddings MUST be identical
    assert_eq!(emb1.vector, emb2.vector, "HDC embeddings must be stable across restarts");
}
```

---
*Task ID: M03-L32*
*Layer: Logic*
*Module: 03 - 12-Model Embedding Pipeline*
