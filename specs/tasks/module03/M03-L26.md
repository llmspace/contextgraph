# Task Specification: M03-L26

```xml
<task_spec id="M03-L26" version="1.0">
<metadata>
  <title>Neuromodulation Integration</title>
  <status>ready</status>
  <layer>logic</layer>
  <sequence>26</sequence>
  <implements>
    - PRD Section 7.2: Neuromodulatory global state
    - Technical Engine Section 9: Dopamine/Serotonin/Noradrenaline hooks
    - Constitution: bioinspired.neuromodulation
  </implements>
  <depends_on>
    - M03-F14 (FusionConfig)
    - M03-L20 (GatingNetwork)
    - M03-L23 (FuseMoE Main Module)
  </depends_on>
  <estimated_hours>5</estimated_hours>
</metadata>

<context>
Implement the Neuromodulation system that dynamically adjusts embedding pipeline
behavior based on global neuromodulator levels. This bio-inspired mechanism allows
the Coherence layer and other system components to influence embedding generation
in real-time.

Key neuromodulators and their effects on the embedding pipeline:
- **Dopamine**: Controls exploration/exploitation in expert selection
- **Serotonin**: Adjusts FuseMoE.top_k (number of active experts)
- **Noradrenaline**: Modulates GatingNetwork temperature (sharpness of routing)
- **Acetylcholine**: Controls attention focus in multimodal model

The system receives modulator signals from upper layers and translates them into
concrete parameter adjustments for the FuseMoE and model weighting systems.
</context>

<definition_of_done>
  <signatures>
```rust
/// Neuromodulator levels (normalized 0.0 - 1.0)
#[derive(Debug, Clone, Copy, Default)]
pub struct NeuromodulatorState {
    /// Exploration/exploitation balance
    pub dopamine: f32,
    /// Expert breadth (top_k adjustment)
    pub serotonin: f32,
    /// Routing sharpness (temperature)
    pub noradrenaline: f32,
    /// Attention focus (multimodal weighting)
    pub acetylcholine: f32,
}

/// Effects computed from neuromodulator state
#[derive(Debug, Clone)]
pub struct ModulationEffects {
    /// Adjusted top_k for FuseMoE (2-8)
    pub fusion_top_k: usize,
    /// Adjusted temperature for gating network
    pub gating_temperature: f32,
    /// Per-model weight multipliers
    pub model_weights: [f32; 12],
    /// Attention scaling for CLIP model
    pub attention_scale: f32,
}

/// Trait for components that can be modulated
pub trait Modulatable {
    /// Apply modulation effects to this component
    fn apply_modulation(&mut self, effects: &ModulationEffects);

    /// Reset to baseline (no modulation)
    fn reset_modulation(&mut self);
}

pub struct NeuromodulationController {
    state: RwLock<NeuromodulatorState>,
    baseline_config: FusionConfig,
    decay_rate: f32,
}

impl NeuromodulationController {
    /// Create controller with baseline configuration
    pub fn new(baseline: FusionConfig) -> Self;

    /// Update neuromodulator levels
    pub fn update_state(&self, delta: NeuromodulatorState);

    /// Set absolute neuromodulator levels
    pub fn set_state(&self, state: NeuromodulatorState);

    /// Get current state
    pub fn current_state(&self) -> NeuromodulatorState;

    /// Compute effects based on current state
    pub fn compute_effects(&self) -> ModulationEffects;

    /// Apply natural decay towards baseline
    pub fn decay(&self, dt_seconds: f32);

    /// Apply modulation to FuseMoE instance
    pub fn modulate_fusemoe(&self, fusemoe: &mut FuseMoE);

    /// Apply modulation to GatingNetwork
    pub fn modulate_gating(&self, gating: &mut GatingNetwork);
}

/// Message for receiving modulation signals
#[derive(Debug, Clone)]
pub enum ModulationSignal {
    /// Reward signal (increases dopamine)
    Reward { value: f32 },
    /// Uncertainty signal (increases noradrenaline)
    Uncertainty { value: f32 },
    /// Focus request (adjusts serotonin/acetylcholine)
    Focus { domain: FocusDomain, intensity: f32 },
    /// Direct state update
    StateUpdate(NeuromodulatorState),
    /// Reset to baseline
    Reset,
}

#[derive(Debug, Clone, Copy)]
pub enum FocusDomain {
    Semantic,
    Temporal,
    Causal,
    Code,
    Visual,
    Broad,
}
```
  </signatures>

  <constraints>
    - Thread-safe: controller usable from multiple async contexts
    - Low latency: compute_effects() <10μs
    - Smooth transitions: changes applied gradually via decay
    - Bounded outputs: all effects clamped to valid ranges
    - Serotonin maps top_k: 0.0→2 experts, 1.0→8 experts
    - Noradrenaline maps temperature: 0.0→1.0 (soft), 1.0→0.1 (sharp)
    - Model weights normalized to sum to 1.0
  </constraints>

  <verification>
    <step>Low serotonin (0.2) → top_k = 2</step>
    <step>High serotonin (0.9) → top_k = 7-8</step>
    <step>High noradrenaline → sharper expert routing</step>
    <step>Dopamine affects exploration in expert selection</step>
    <step>FocusDomain::Code increases E7 (CodeBERT) weight</step>
    <step>Decay naturally returns to baseline over time</step>
    <step>ModulationSignal::Reset restores defaults</step>
  </verification>
</definition_of_done>

<files_to_create>
  <file>crates/context-graph-embeddings/src/modulation/controller.rs</file>
  <file>crates/context-graph-embeddings/src/modulation/effects.rs</file>
  <file>crates/context-graph-embeddings/src/modulation/mod.rs</file>
</files_to_create>

<validation_criteria>
  <criterion>cargo check passes</criterion>
  <criterion>cargo test modulation passes</criterion>
  <criterion>Effect computation <10μs (benchmark test)</criterion>
  <criterion>All modulation values bounded correctly</criterion>
  <criterion>Decay converges to baseline</criterion>
</validation_criteria>
</task_spec>
```

## Implementation Notes

### Modulation Mapping Functions

```rust
impl NeuromodulationController {
    fn serotonin_to_top_k(&self, serotonin: f32) -> usize {
        // 0.0 → 2 experts, 1.0 → 8 experts
        let scaled = 2.0 + (serotonin * 6.0);
        scaled.round() as usize
    }

    fn noradrenaline_to_temperature(&self, noradrenaline: f32) -> f32 {
        // 0.0 → 1.0 (soft routing), 1.0 → 0.1 (sharp routing)
        1.0 - (noradrenaline * 0.9)
    }

    fn focus_to_model_weights(&self, domain: FocusDomain, intensity: f32) -> [f32; 12] {
        let mut weights = [1.0; 12];
        match domain {
            FocusDomain::Code => weights[6] *= 1.0 + intensity,    // E7 CodeBERT
            FocusDomain::Visual => weights[9] *= 1.0 + intensity,  // E10 CLIP
            FocusDomain::Temporal => {
                weights[1] *= 1.0 + intensity;  // E2 Recent
                weights[2] *= 1.0 + intensity;  // E3 Periodic
                weights[3] *= 1.0 + intensity;  // E4 Positional
            }
            FocusDomain::Causal => weights[4] *= 1.0 + intensity,  // E5 Longformer
            FocusDomain::Semantic => weights[0] *= 1.0 + intensity, // E1 E5-large
            FocusDomain::Broad => { /* no adjustment */ }
        }
        // Normalize
        let sum: f32 = weights.iter().sum();
        for w in &mut weights {
            *w /= sum;
        }
        weights
    }
}
```

### Integration with FuseMoE

```rust
impl Modulatable for FuseMoE {
    fn apply_modulation(&mut self, effects: &ModulationEffects) {
        self.set_top_k(effects.fusion_top_k);
        self.gating.set_temperature(effects.gating_temperature);
    }

    fn reset_modulation(&mut self) {
        self.set_top_k(self.config.default_top_k);
        self.gating.set_temperature(self.config.default_temperature);
    }
}
```

---
*Task ID: M03-L26*
*Layer: Logic*
*Module: 03 - 12-Model Embedding Pipeline*
