# Task Specification: M03-F08

## METADATA
| Field | Value |
|-------|-------|
| **Task ID** | M03-F08 |
| **Title** | Extend EmbeddingError Enum with All Error Variants |
| **Status** | COMPLETE |
| **Layer** | foundation |
| **Sequence** | 8 |
| **Implements** | constitution.yaml: embeddings.error_handling |
| **Depends On** | M03-F01 (ModelId), M03-F06 (ModelInput), M03-F07 (InputType) |
| **Estimated Hours** | 2 |
| **Crate** | context-graph-embeddings |

---

## IMPLEMENTATION STATUS: ✅ COMPLETE

### Verified Implementation
**Location**: `crates/context-graph-embeddings/src/error.rs`

**Implementation verified** (as of 2026-01-01):
```rust
#[derive(Debug, Error)]
pub enum EmbeddingError {
    // Model Errors (3)
    ModelNotFound { model_id: ModelId },                    // ✅ Implemented
    ModelLoadError { model_id: ModelId, #[source] source }, // ✅ Implemented with error chain
    NotInitialized { model_id: ModelId },                   // ✅ Implemented

    // Validation Errors (4)
    InvalidDimension { expected: usize, actual: usize },    // ✅ Implemented
    InvalidValue { index: usize, value: f32 },              // ✅ Implemented
    EmptyInput,                                             // ✅ Implemented
    InputTooLong { actual: usize, max: usize },             // ✅ Implemented

    // Processing Errors (3)
    BatchError { message: String },                         // ✅ Implemented
    FusionError { message: String },                        // ✅ Implemented
    TokenizationError { message: String },                  // ✅ Implemented

    // Infrastructure Errors (4)
    GpuError { message: String },                           // ✅ Implemented
    CacheError { message: String },                         // ✅ Implemented
    IoError(#[from] std::io::Error),                        // ✅ Implemented
    Timeout { timeout_ms: u64 },                            // ✅ Implemented

    // Configuration Errors (2)
    UnsupportedModality { model_id: ModelId, input_type: InputType }, // ✅ Implemented
    ConfigError { message: String },                        // ✅ Implemented

    // Serialization Errors (1)
    SerializationError { message: String },                 // ✅ Implemented
}

pub type EmbeddingResult<T> = Result<T, EmbeddingError>;    // ✅ Implemented
```

### Dependencies (All Implemented)
- **ModelId**: `crates/context-graph-embeddings/src/types/model_id.rs` (12 variants, E1-E12)
- **InputType**: `crates/context-graph-embeddings/src/types/input.rs` (4 variants: Text, Code, Image, Audio)
- Both exported via `types/mod.rs`

### Forensic Verification (sherlock-holmes)
- **Variants**: 17/17 present across 6 categories
- **Send + Sync**: Compile-time verified
- **Error chain**: `#[source]` on ModelLoadError verified
- **Tests**: 37 tests (exceeds 27+ requirement)
- **Mock data**: NONE - All tests use real ModelId and InputType values
- **Verdict**: INNOCENT - Fully compliant

---

## REQUIRED CHANGES

Replace the entire `error.rs` with the complete error enum. **NO BACKWARDS COMPATIBILITY** - existing code using removed variants must be updated to use correct variants.

### Target File
`crates/context-graph-embeddings/src/error.rs`

### Required Signature
```rust
use thiserror::Error;
use crate::types::{ModelId, InputType};

/// Comprehensive error type for all embedding pipeline failures.
///
/// # Error Categories
///
/// | Category | Variants | Recovery Strategy |
/// |----------|----------|-------------------|
/// | Model | ModelNotFound, ModelLoadError, NotInitialized | Retry with different config |
/// | Validation | InvalidDimension, InvalidValue, EmptyInput, InputTooLong | Fix input data |
/// | Processing | BatchError, FusionError, TokenizationError | Retry or fallback model |
/// | Infrastructure | GpuError, CacheError, IoError, Timeout | Retry or degrade |
/// | Configuration | ConfigError, UnsupportedModality | Fix configuration |
/// | Serialization | SerializationError | Fix data format |
///
/// # Design Principles
///
/// - **NO FALLBACKS**: Errors must propagate, not be silently handled
/// - **FAIL FAST**: Invalid state triggers immediate error
/// - **CONTEXTUAL**: Every variant includes debugging information
/// - **TRACEABLE**: Error chain preserved via `source`
#[derive(Debug, Error)]
pub enum EmbeddingError {
    // === Model Errors ===

    /// Model with given ID not registered in ModelRegistry.
    #[error("Model not found: {model_id:?}")]
    ModelNotFound { model_id: ModelId },

    /// Model weight loading failed (HuggingFace download, ONNX parse, etc).
    #[error("Model load failed for {model_id:?}: {source}")]
    ModelLoadError {
        model_id: ModelId,
        #[source]
        source: Box<dyn std::error::Error + Send + Sync>,
    },

    /// Model exists but embed() called before initialize().
    #[error("Model not initialized: {model_id:?}")]
    NotInitialized { model_id: ModelId },

    // === Validation Errors ===

    /// Embedding vector dimension mismatch.
    #[error("Invalid dimension: expected {expected}, got {actual}")]
    InvalidDimension { expected: usize, actual: usize },

    /// Embedding contains NaN or Infinity at specific index.
    #[error("Invalid embedding value at index {index}: {value}")]
    InvalidValue { index: usize, value: f32 },

    /// Empty input provided (text, code, bytes).
    #[error("Empty input not allowed")]
    EmptyInput,

    /// Input exceeds model's max token limit.
    #[error("Input too long: {actual} tokens exceeds max {max}")]
    InputTooLong { actual: usize, max: usize },

    // === Processing Errors ===

    /// Batch processing failed (queue overflow, timeout, partial failure).
    #[error("Batch processing error: {message}")]
    BatchError { message: String },

    /// FuseMoE fusion failed (expert routing, gating, aggregation).
    #[error("Fusion error: {message}")]
    FusionError { message: String },

    /// Tokenization failed (unknown tokens, encoding error).
    #[error("Tokenization error: {message}")]
    TokenizationError { message: String },

    // === Infrastructure Errors ===

    /// GPU/CUDA operation failed.
    #[error("GPU error: {message}")]
    GpuError { message: String },

    /// Embedding cache operation failed (LRU eviction, disk I/O).
    #[error("Cache error: {message}")]
    CacheError { message: String },

    /// File I/O error (model weights, config files).
    #[error("IO error: {0}")]
    IoError(#[from] std::io::Error),

    /// Operation exceeded timeout threshold.
    #[error("Operation timeout after {timeout_ms}ms")]
    Timeout { timeout_ms: u64 },

    // === Configuration Errors ===

    /// Model does not support the given input type.
    #[error("Unsupported input type {input_type:?} for model {model_id:?}")]
    UnsupportedModality { model_id: ModelId, input_type: InputType },

    /// Configuration file invalid or missing required fields.
    #[error("Configuration error: {message}")]
    ConfigError { message: String },

    // === Serialization Errors ===

    /// Serialization/deserialization failed (JSON, binary, protobuf).
    #[error("Serialization error: {message}")]
    SerializationError { message: String },
}

/// Result type alias for embedding operations.
pub type EmbeddingResult<T> = Result<T, EmbeddingError>;
```

---

## IMPLEMENTATION REQUIREMENTS

### 1. Imports
```rust
use thiserror::Error;
use crate::types::{ModelId, InputType};
```

### 2. Constraints
| Constraint | Requirement |
|------------|-------------|
| Derive | `thiserror::Error` for Display/Error |
| Debug | Must derive `Debug` |
| Send + Sync | Required for async - `Box<dyn Error + Send + Sync>` |
| From<io::Error> | Use `#[from]` attribute |
| No Clone | Intentionally NOT Clone (contains `Box<dyn Error>`) |

### 3. Variant Count
- **17 variants total** (see signature above)
- Removed from current: `GenerationError`, `ExpertWeightsInvalid`, `InvalidExpertIndex`, `CompressionError`, `InvalidAuxData`
- Added: `ModelNotFound`, `NotInitialized`, `InvalidValue`, `EmptyInput`, `InputTooLong`, `BatchError`, `FusionError`, `TokenizationError`, `GpuError`, `CacheError`, `Timeout`, `UnsupportedModality`, `ConfigError`

---

## TESTS TO IMPLEMENT

### Required Test Categories

```rust
#[cfg(test)]
mod tests {
    use super::*;

    // === Creation Tests (17 tests, one per variant) ===

    #[test]
    fn test_model_not_found_error_creation() {
        let err = EmbeddingError::ModelNotFound { model_id: ModelId::Semantic };
        let msg = format!("{}", err);
        assert!(msg.contains("Semantic"));
        assert!(msg.contains("not found"));
    }

    #[test]
    fn test_model_load_error_preserves_source() {
        let source = std::io::Error::new(std::io::ErrorKind::NotFound, "weights missing");
        let err = EmbeddingError::ModelLoadError {
            model_id: ModelId::Code,
            source: Box::new(source),
        };
        let msg = format!("{}", err);
        assert!(msg.contains("Code"));
        assert!(msg.contains("weights missing"));
        // Verify source chain
        assert!(err.source().is_some());
    }

    #[test]
    fn test_invalid_dimension_shows_both_values() {
        let err = EmbeddingError::InvalidDimension { expected: 1536, actual: 768 };
        let msg = format!("{}", err);
        assert!(msg.contains("1536"));
        assert!(msg.contains("768"));
    }

    #[test]
    fn test_invalid_value_shows_index_and_value() {
        let err = EmbeddingError::InvalidValue { index: 42, value: f32::NAN };
        let msg = format!("{}", err);
        assert!(msg.contains("42"));
        assert!(msg.contains("NaN"));
    }

    #[test]
    fn test_empty_input_error_message() {
        let err = EmbeddingError::EmptyInput;
        let msg = format!("{}", err);
        assert!(msg.contains("Empty"));
    }

    #[test]
    fn test_input_too_long_shows_limits() {
        let err = EmbeddingError::InputTooLong { actual: 600, max: 512 };
        let msg = format!("{}", err);
        assert!(msg.contains("600"));
        assert!(msg.contains("512"));
    }

    #[test]
    fn test_unsupported_modality_shows_both() {
        let err = EmbeddingError::UnsupportedModality {
            model_id: ModelId::Semantic,
            input_type: InputType::Image,
        };
        let msg = format!("{}", err);
        assert!(msg.contains("Semantic"));
        assert!(msg.contains("Image"));
    }

    // ... similar tests for remaining 10 variants ...

    // === Send + Sync Tests ===

    #[test]
    fn test_embedding_error_is_send() {
        fn assert_send<T: Send>() {}
        assert_send::<EmbeddingError>();
    }

    #[test]
    fn test_embedding_error_is_sync() {
        fn assert_sync<T: Sync>() {}
        assert_sync::<EmbeddingError>();
    }

    // === From<io::Error> Test ===

    #[test]
    fn test_io_error_conversion_via_question_mark() {
        fn fallible_io() -> EmbeddingResult<()> {
            let _ = std::fs::read("/nonexistent/path")?;
            Ok(())
        }
        let result = fallible_io();
        assert!(matches!(result, Err(EmbeddingError::IoError(_))));
    }

    // === EmbeddingResult Alias Test ===

    #[test]
    fn test_embedding_result_alias_works() {
        fn returns_ok() -> EmbeddingResult<i32> {
            Ok(42)
        }
        fn returns_err() -> EmbeddingResult<i32> {
            Err(EmbeddingError::EmptyInput)
        }
        assert_eq!(returns_ok().unwrap(), 42);
        assert!(returns_err().is_err());
    }

    // === Debug Formatting Test ===

    #[test]
    fn test_debug_formatting_includes_variant_name() {
        let err = EmbeddingError::Timeout { timeout_ms: 5000 };
        let debug = format!("{:?}", err);
        assert!(debug.contains("Timeout"));
        assert!(debug.contains("5000"));
    }

    // === Edge Cases ===

    #[test]
    fn test_all_12_model_ids_in_model_not_found() {
        for model_id in ModelId::all() {
            let err = EmbeddingError::ModelNotFound { model_id: *model_id };
            let msg = format!("{}", err);
            // Verify error message is non-empty and contains model info
            assert!(!msg.is_empty());
            println!("BEFORE: ModelId::{:?}", model_id);
            println!("AFTER: Error message = {}", msg);
        }
    }

    #[test]
    fn test_all_4_input_types_in_unsupported_modality() {
        for input_type in InputType::all() {
            let err = EmbeddingError::UnsupportedModality {
                model_id: ModelId::Semantic,
                input_type: *input_type,
            };
            let msg = format!("{}", err);
            assert!(!msg.is_empty());
            println!("BEFORE: InputType::{:?}", input_type);
            println!("AFTER: Error message = {}", msg);
        }
    }

    #[test]
    fn test_invalid_value_with_infinity() {
        let err = EmbeddingError::InvalidValue { index: 0, value: f32::INFINITY };
        let msg = format!("{}", err);
        assert!(msg.contains("inf"));
    }

    #[test]
    fn test_invalid_value_with_neg_infinity() {
        let err = EmbeddingError::InvalidValue { index: 0, value: f32::NEG_INFINITY };
        let msg = format!("{}", err);
        assert!(msg.contains("-inf") || msg.contains("inf"));
    }
}
```

---

## FULL STATE VERIFICATION

After implementing, you MUST verify:

### 1. Source of Truth
- **File**: `crates/context-graph-embeddings/src/error.rs`
- **Exported**: Via `lib.rs` as `pub use error::{EmbeddingError, EmbeddingResult};`

### 2. Verification Commands
```bash
# Compile check - must pass with no errors
cargo check -p context-graph-embeddings

# Run tests - all must pass
cargo test -p context-graph-embeddings error::tests -- --nocapture

# Verify exports work from lib.rs
cargo test -p context-graph-embeddings --lib

# Verify no clippy warnings
cargo clippy -p context-graph-embeddings -- -D warnings
```

### 3. Manual Edge Case Verification

Run these tests and print state before/after:

```bash
cargo test -p context-graph-embeddings test_all_12_model_ids_in_model_not_found -- --nocapture
cargo test -p context-graph-embeddings test_all_4_input_types_in_unsupported_modality -- --nocapture
cargo test -p context-graph-embeddings test_invalid_value_with_infinity -- --nocapture
cargo test -p context-graph-embeddings test_io_error_conversion_via_question_mark -- --nocapture
```

### 4. Evidence of Success
After running `cargo test -p context-graph-embeddings error`, output should show:
```
running 25+ tests
test error::tests::test_model_not_found_error_creation ... ok
test error::tests::test_model_load_error_preserves_source ... ok
...
test result: ok. 25+ passed; 0 failed
```

---

## BREAKING CHANGES

Code using these OLD variants must be updated:

| Old Variant | New Variant | Migration |
|-------------|-------------|-----------|
| `GenerationError(String)` | `BatchError { message }` or specific variant | Update call sites |
| `InvalidInput(String)` | `EmptyInput` or `InputTooLong` | Use specific variant |
| `InvalidVector(String)` | `InvalidValue { index, value }` | Include index/value |
| `ExpertWeightsInvalid` | `FusionError { message }` | Move to FuseMoE context |
| `InvalidExpertIndex` | `FusionError { message }` | Move to FuseMoE context |
| `CompressionError` | REMOVE | Not in spec |
| `InvalidAuxData` | REMOVE | Not in spec |

---

## FINAL VERIFICATION CHECKLIST

- [ ] File compiles: `cargo check -p context-graph-embeddings`
- [ ] All 17 variants present
- [ ] Uses `thiserror::Error` derive
- [ ] `EmbeddingResult<T>` alias defined
- [ ] `#[from] std::io::Error` on IoError variant
- [ ] `#[source]` on ModelLoadError.source field
- [ ] Imports `ModelId` and `InputType` from `crate::types`
- [ ] All error messages include contextual information
- [ ] Debug derive present
- [ ] Send + Sync (verified by test)
- [ ] All tests pass: `cargo test -p context-graph-embeddings error`
- [ ] No clippy warnings: `cargo clippy -p context-graph-embeddings -- -D warnings`

---

## SHERLOCK-HOLMES VERIFICATION

After implementation, spawn `sherlock-holmes` agent to verify:
1. All 17 variants are implemented exactly as specified
2. Error messages match the `#[error("...")]` format strings
3. `ModelId` and `InputType` imports resolve correctly
4. `From<io::Error>` conversion works via `?` operator
5. Error chain (`source()`) works for `ModelLoadError`
6. All tests pass with real assertions (no mock data)
7. Exported correctly from `lib.rs`

---

*Task Completed: 2026-01-01*
*Verified by: sherlock-holmes forensic agent*
*Tests: 37 passed, 0 failed (244 total in crate)*
*Module: 03 - 12-Model Embedding Pipeline*
*Version: 2.0.0*
