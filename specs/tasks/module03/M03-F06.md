# Task Specification: M03-F06

```xml
<task_spec id="M03-F06" version="1.0">
<metadata>
  <title>Define ModelInput Enum for Multi-Modal Inputs</title>
  <status>ready</status>
  <layer>foundation</layer>
  <sequence>6</sequence>
  <implements>constitution.yaml: embeddings.input_types</implements>
  <depends_on>none</depends_on>
  <estimated_hours>1.5</estimated_hours>
</metadata>

<context>
Implement ModelInput enum supporting text, code, image, and audio inputs.
This enum provides a unified interface for passing different types of content
to the embedding pipeline, allowing models to handle inputs they support.

Each variant carries the data needed for that input type:
- Text: content string with optional instruction prefix (for e5-style models)
- Code: source code with language identifier
- Image: raw bytes with format information
- Audio: raw bytes with sample rate and channel count
</context>

<definition_of_done>
  <signatures>
```rust
#[derive(Debug, Clone)]
pub enum ModelInput {
    Text { content: String, instruction: Option<String> },
    Code { content: String, language: String },
    Image { bytes: Vec<u8>, format: ImageFormat },
    Audio { bytes: Vec<u8>, sample_rate: u32, channels: u8 },
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum ImageFormat { Png, Jpeg, WebP, Gif }

impl ModelInput {
    pub fn text(content: impl Into<String>) -> Self;
    pub fn code(content: impl Into<String>, language: impl Into<String>) -> Self;
    pub fn image(bytes: Vec<u8>, format: ImageFormat) -> Self;
    pub fn audio(bytes: Vec<u8>, sample_rate: u32, channels: u8) -> Self;
    pub fn content_hash(&self) -> u64;
    pub fn byte_size(&self) -> usize;
    pub fn is_text(&self) -> bool;
    pub fn is_code(&self) -> bool;
    pub fn is_image(&self) -> bool;
    pub fn is_audio(&self) -> bool;
}
```
  </signatures>

  <constraints>
    <constraint>content_hash() must produce consistent hashes for identical content</constraint>
    <constraint>byte_size() must accurately report memory usage</constraint>
    <constraint>Text content must not be empty</constraint>
    <constraint>Image bytes must not be empty</constraint>
    <constraint>Audio sample_rate must be positive</constraint>
    <constraint>Audio channels must be 1 (mono) or 2 (stereo)</constraint>
  </constraints>

  <verification>
    <check>text() creates Text variant correctly</check>
    <check>code() creates Code variant correctly</check>
    <check>image() creates Image variant correctly</check>
    <check>audio() creates Audio variant correctly</check>
    <check>content_hash() same for identical content</check>
    <check>content_hash() different for different content</check>
    <check>byte_size() returns correct size for each variant</check>
    <check>Type predicates (is_text, is_code, etc.) work correctly</check>
  </verification>
</definition_of_done>

<files_to_create>
  <file>crates/context-graph-embeddings/src/types/input.rs</file>
</files_to_create>

<validation_criteria>
  <criterion>cargo check passes</criterion>
  <criterion>cargo test passes</criterion>
  <criterion>All constructors compile with Into<String> bounds</criterion>
  <criterion>Hash function is deterministic</criterion>
</validation_criteria>

<supported_languages>
Common code languages to support:
- rust, python, javascript, typescript
- java, kotlin, scala
- go, c, cpp, csharp
- ruby, php, swift
- sql, html, css, json, yaml, toml
- bash, powershell
- markdown, plaintext
</supported_languages>

<hash_implementation>
Use a fast, stable hash algorithm:
- xxhash64 or FNV-1a recommended
- Hash should include all fields for the variant
- For binary data (Image, Audio), hash the raw bytes
- For text, normalize to UTF-8 before hashing
</hash_implementation>
</task_spec>
```
