# TASK-M02-011: Implement GraphEdge Methods

```xml
<task_spec id="TASK-M02-011" version="2.0">
<metadata>
  <title>Implement GraphEdge Methods</title>
  <status>complete</status>
  <layer>foundation</layer>
  <module>module-02</module>
  <sequence>11</sequence>
  <priority>critical</priority>
  <estimated_hours>2.5</estimated_hours>
  <implements>
    <item>TECH-CORE-002 Section 2.5: GraphEdge methods specification</item>
    <item>Marblestone Integration Spec: Modulated weight calculation</item>
    <item>constitution.yaml edge_model section</item>
  </implements>
  <depends_on>
    <task_ref status="COMPLETE">TASK-M02-010 (GraphEdge struct with 13 fields)</task_ref>
    <task_ref status="COMPLETE">TASK-M02-008 (NeurotransmitterWeights with compute_effective_weight)</task_ref>
    <task_ref status="COMPLETE">TASK-M02-009 (EdgeType with default_weight)</task_ref>
    <task_ref status="COMPLETE">TASK-M02-007 (Domain enum)</task_ref>
  </depends_on>
</metadata>
</task_spec>
```

## Current Codebase State (2025-12-31)

### Source of Truth Files
| File | Purpose | Line Count |
|------|---------|------------|
| `crates/context-graph-core/src/types/graph_edge.rs` | **GraphEdge struct** (13 fields, NO methods yet) | 489 lines |
| `crates/context-graph-core/src/marblestone.rs` | Domain, EdgeType, NeurotransmitterWeights | 1159 lines |
| `crates/context-graph-core/src/lib.rs` | Crate root, re-exports Domain/EdgeType/NeurotransmitterWeights | 32 lines |

### GraphEdge Struct (Already Exists - DO NOT RECREATE)
Location: `crates/context-graph-core/src/types/graph_edge.rs:82-129`

```rust
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct GraphEdge {
    pub id: EdgeId,                                    // UUID v4
    pub source_id: NodeId,                             // UUID
    pub target_id: NodeId,                             // UUID
    pub edge_type: EdgeType,                           // from marblestone.rs
    pub weight: f32,                                   // [0.0, 1.0]
    pub confidence: f32,                               // [0.0, 1.0]
    pub domain: Domain,                                // from marblestone.rs
    pub neurotransmitter_weights: NeurotransmitterWeights, // from marblestone.rs
    pub is_amortized_shortcut: bool,
    pub steering_reward: f32,                          // [-1.0, 1.0]
    pub traversal_count: u64,
    pub created_at: DateTime<Utc>,
    pub last_traversed_at: Option<DateTime<Utc>>,
}
```

### Already Available Dependencies
```rust
// Already imported at graph_edge.rs:14-19
use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use uuid::Uuid;
use super::NodeId;  // from types/mod.rs re-exports
use crate::marblestone::{Domain, EdgeType, NeurotransmitterWeights};

// Type alias at line 22
pub type EdgeId = Uuid;
```

### NeurotransmitterWeights::compute_effective_weight (ALREADY EXISTS)
Location: `crates/context-graph-core/src/marblestone.rs:251-258`
```rust
pub fn compute_effective_weight(&self, base_weight: f32) -> f32 {
    let signal = base_weight * self.excitatory - base_weight * self.inhibitory;
    let mod_factor = 1.0 + (self.modulatory - 0.5) * 0.4;
    (signal * mod_factor).clamp(0.0, 1.0)
}
```

### EdgeType::default_weight (ALREADY EXISTS)
Location: `crates/context-graph-core/src/marblestone.rs:377-385`
```rust
pub fn default_weight(&self) -> f32 {
    match self {
        Self::Semantic => 0.5,
        Self::Temporal => 0.7,
        Self::Causal => 0.8,
        Self::Hierarchical => 0.9,
    }
}
```

---

## Exact Implementation Required

### File to Modify
**`crates/context-graph-core/src/types/graph_edge.rs`**

### Insert Location
After line 129 (closing brace of `GraphEdge` struct), BEFORE line 131 (`#[cfg(test)]`).

### Code to Add (Copy Exactly)

```rust
impl GraphEdge {
    /// Create a new edge with default values for the given domain.
    ///
    /// # Arguments
    /// * `source_id` - Source node UUID
    /// * `target_id` - Target node UUID
    /// * `edge_type` - Type of relationship
    /// * `domain` - Knowledge domain (determines NT weights)
    ///
    /// # Returns
    /// New GraphEdge with:
    /// - weight = edge_type.default_weight()
    /// - confidence = 0.5
    /// - neurotransmitter_weights = NeurotransmitterWeights::for_domain(domain)
    /// - steering_reward = 0.0
    /// - traversal_count = 0
    /// - is_amortized_shortcut = false
    ///
    /// # Example
    /// ```rust
    /// use context_graph_core::types::GraphEdge;
    /// use context_graph_core::marblestone::{Domain, EdgeType};
    /// use uuid::Uuid;
    ///
    /// let edge = GraphEdge::new(
    ///     Uuid::new_v4(),
    ///     Uuid::new_v4(),
    ///     EdgeType::Causal,
    ///     Domain::Code,
    /// );
    /// assert_eq!(edge.weight, 0.8); // Causal default
    /// ```
    pub fn new(
        source_id: NodeId,
        target_id: NodeId,
        edge_type: EdgeType,
        domain: Domain,
    ) -> Self {
        let now = Utc::now();
        Self {
            id: Uuid::new_v4(),
            source_id,
            target_id,
            edge_type,
            weight: edge_type.default_weight(),
            confidence: 0.5,
            domain,
            neurotransmitter_weights: NeurotransmitterWeights::for_domain(domain),
            is_amortized_shortcut: false,
            steering_reward: 0.0,
            traversal_count: 0,
            created_at: now,
            last_traversed_at: None,
        }
    }

    /// Create a new edge with explicit weight and confidence.
    ///
    /// # Arguments
    /// * `source_id` - Source node UUID
    /// * `target_id` - Target node UUID
    /// * `edge_type` - Type of relationship
    /// * `domain` - Knowledge domain
    /// * `weight` - Base edge weight (will be clamped to [0.0, 1.0])
    /// * `confidence` - Confidence level (will be clamped to [0.0, 1.0])
    ///
    /// # Example
    /// ```rust
    /// use context_graph_core::types::GraphEdge;
    /// use context_graph_core::marblestone::{Domain, EdgeType};
    /// use uuid::Uuid;
    ///
    /// let edge = GraphEdge::with_weight(
    ///     Uuid::new_v4(),
    ///     Uuid::new_v4(),
    ///     EdgeType::Semantic,
    ///     Domain::Research,
    ///     0.75,
    ///     0.95,
    /// );
    /// assert_eq!(edge.weight, 0.75);
    /// assert_eq!(edge.confidence, 0.95);
    /// ```
    pub fn with_weight(
        source_id: NodeId,
        target_id: NodeId,
        edge_type: EdgeType,
        domain: Domain,
        weight: f32,
        confidence: f32,
    ) -> Self {
        let mut edge = Self::new(source_id, target_id, edge_type, domain);
        edge.weight = weight.clamp(0.0, 1.0);
        edge.confidence = confidence.clamp(0.0, 1.0);
        edge
    }

    /// Get the modulated weight considering NT weights and steering reward.
    ///
    /// # Formula
    /// ```text
    /// nt_factor = neurotransmitter_weights.compute_effective_weight(weight)
    /// modulated = (nt_factor * (1.0 + steering_reward * 0.2)).clamp(0.0, 1.0)
    /// ```
    ///
    /// Per constitution.yaml dopamine feedback: `pos: "+=r×0.2", neg: "-=|r|×0.1"`
    ///
    /// # Returns
    /// Effective weight in [0.0, 1.0], never NaN or Infinity.
    ///
    /// # Example
    /// ```rust
    /// use context_graph_core::types::GraphEdge;
    /// use context_graph_core::marblestone::{Domain, EdgeType};
    /// use uuid::Uuid;
    ///
    /// let mut edge = GraphEdge::new(
    ///     Uuid::new_v4(),
    ///     Uuid::new_v4(),
    ///     EdgeType::Semantic,
    ///     Domain::General,
    /// );
    /// edge.steering_reward = 0.5;
    /// let modulated = edge.get_modulated_weight();
    /// assert!(modulated >= 0.0 && modulated <= 1.0);
    /// ```
    #[inline]
    pub fn get_modulated_weight(&self) -> f32 {
        let nt_factor = self.neurotransmitter_weights.compute_effective_weight(self.weight);
        (nt_factor * (1.0 + self.steering_reward * 0.2)).clamp(0.0, 1.0)
    }

    /// Apply a steering reward signal from the Steering Subsystem.
    ///
    /// Accumulates reward (additive), clamped to [-1.0, 1.0].
    /// Per constitution.yaml steering.reward: `range: "[-1,1]"`
    ///
    /// # Arguments
    /// * `reward` - Reward signal to add (positive reinforces, negative discourages)
    ///
    /// # Example
    /// ```rust
    /// use context_graph_core::types::GraphEdge;
    /// use context_graph_core::marblestone::{Domain, EdgeType};
    /// use uuid::Uuid;
    ///
    /// let mut edge = GraphEdge::new(
    ///     Uuid::new_v4(),
    ///     Uuid::new_v4(),
    ///     EdgeType::Semantic,
    ///     Domain::General,
    /// );
    /// edge.apply_steering_reward(0.5);
    /// assert_eq!(edge.steering_reward, 0.5);
    /// edge.apply_steering_reward(0.8);
    /// assert_eq!(edge.steering_reward, 1.0); // Clamped
    /// ```
    #[inline]
    pub fn apply_steering_reward(&mut self, reward: f32) {
        self.steering_reward = (self.steering_reward + reward).clamp(-1.0, 1.0);
    }

    /// Decay the steering reward by a factor.
    ///
    /// Used to gradually reduce influence of old rewards over time.
    /// Does NOT clamp - assumes decay_factor is in [0.0, 1.0].
    ///
    /// # Arguments
    /// * `decay_factor` - Multiplicative decay (e.g., 0.9 reduces by 10%)
    ///
    /// # Example
    /// ```rust
    /// use context_graph_core::types::GraphEdge;
    /// use context_graph_core::marblestone::{Domain, EdgeType};
    /// use uuid::Uuid;
    ///
    /// let mut edge = GraphEdge::new(
    ///     Uuid::new_v4(),
    ///     Uuid::new_v4(),
    ///     EdgeType::Semantic,
    ///     Domain::General,
    /// );
    /// edge.steering_reward = 1.0;
    /// edge.decay_steering(0.5);
    /// assert_eq!(edge.steering_reward, 0.5);
    /// ```
    #[inline]
    pub fn decay_steering(&mut self, decay_factor: f32) {
        self.steering_reward *= decay_factor;
    }

    /// Record a traversal of this edge.
    ///
    /// Updates traversal_count (saturating) and last_traversed_at timestamp.
    /// Per constitution.yaml dream.amortized: `trigger: "3+ hop path traversed ≥5×"`
    ///
    /// # Example
    /// ```rust
    /// use context_graph_core::types::GraphEdge;
    /// use context_graph_core::marblestone::{Domain, EdgeType};
    /// use uuid::Uuid;
    ///
    /// let mut edge = GraphEdge::new(
    ///     Uuid::new_v4(),
    ///     Uuid::new_v4(),
    ///     EdgeType::Semantic,
    ///     Domain::General,
    /// );
    /// assert!(edge.last_traversed_at.is_none());
    /// edge.record_traversal();
    /// assert_eq!(edge.traversal_count, 1);
    /// assert!(edge.last_traversed_at.is_some());
    /// ```
    #[inline]
    pub fn record_traversal(&mut self) {
        self.traversal_count = self.traversal_count.saturating_add(1);
        self.last_traversed_at = Some(Utc::now());
    }

    /// Check if this edge is a reliable amortized shortcut.
    ///
    /// Per constitution.yaml edge_model.amortized:
    /// - `trigger: "3+ hop path traversed ≥5×"` (we check traversal_count >= 3)
    /// - `confidence: "≥0.7"`
    /// - `steering_reward > 0.3` (positive feedback)
    /// - `is_amortized_shortcut == true`
    ///
    /// # Returns
    /// `true` if ALL conditions are met:
    /// 1. `is_amortized_shortcut == true`
    /// 2. `traversal_count >= 3`
    /// 3. `steering_reward > 0.3`
    /// 4. `confidence >= 0.7`
    ///
    /// # Example
    /// ```rust
    /// use context_graph_core::types::GraphEdge;
    /// use context_graph_core::marblestone::{Domain, EdgeType};
    /// use uuid::Uuid;
    ///
    /// let mut edge = GraphEdge::new(
    ///     Uuid::new_v4(),
    ///     Uuid::new_v4(),
    ///     EdgeType::Semantic,
    ///     Domain::General,
    /// );
    /// assert!(!edge.is_reliable_shortcut()); // Not a shortcut
    ///
    /// edge.is_amortized_shortcut = true;
    /// edge.traversal_count = 5;
    /// edge.steering_reward = 0.5;
    /// edge.confidence = 0.8;
    /// assert!(edge.is_reliable_shortcut());
    /// ```
    #[inline]
    pub fn is_reliable_shortcut(&self) -> bool {
        self.is_amortized_shortcut
            && self.traversal_count >= 3
            && self.steering_reward > 0.3
            && self.confidence >= 0.7
    }

    /// Mark this edge as an amortized shortcut.
    ///
    /// Called during dream consolidation when a 3+ hop path has been
    /// traversed enough times to warrant a direct shortcut edge.
    ///
    /// # Example
    /// ```rust
    /// use context_graph_core::types::GraphEdge;
    /// use context_graph_core::marblestone::{Domain, EdgeType};
    /// use uuid::Uuid;
    ///
    /// let mut edge = GraphEdge::new(
    ///     Uuid::new_v4(),
    ///     Uuid::new_v4(),
    ///     EdgeType::Semantic,
    ///     Domain::General,
    /// );
    /// assert!(!edge.is_amortized_shortcut);
    /// edge.mark_as_shortcut();
    /// assert!(edge.is_amortized_shortcut);
    /// ```
    #[inline]
    pub fn mark_as_shortcut(&mut self) {
        self.is_amortized_shortcut = true;
    }

    /// Get the age of this edge in seconds since creation.
    ///
    /// # Returns
    /// Number of seconds since created_at. Always >= 0.
    ///
    /// # Example
    /// ```rust
    /// use context_graph_core::types::GraphEdge;
    /// use context_graph_core::marblestone::{Domain, EdgeType};
    /// use uuid::Uuid;
    ///
    /// let edge = GraphEdge::new(
    ///     Uuid::new_v4(),
    ///     Uuid::new_v4(),
    ///     EdgeType::Semantic,
    ///     Domain::General,
    /// );
    /// let age = edge.age_seconds();
    /// assert!(age >= 0);
    /// ```
    #[inline]
    pub fn age_seconds(&self) -> i64 {
        (Utc::now() - self.created_at).num_seconds()
    }
}

impl Default for GraphEdge {
    /// Creates a default edge with nil UUIDs.
    ///
    /// Uses:
    /// - source_id/target_id: Uuid::nil()
    /// - edge_type: EdgeType::Semantic (default)
    /// - domain: Domain::General (default)
    ///
    /// # Example
    /// ```rust
    /// use context_graph_core::types::GraphEdge;
    /// use context_graph_core::marblestone::{Domain, EdgeType};
    /// use uuid::Uuid;
    ///
    /// let edge = GraphEdge::default();
    /// assert_eq!(edge.source_id, Uuid::nil());
    /// assert_eq!(edge.target_id, Uuid::nil());
    /// assert_eq!(edge.edge_type, EdgeType::Semantic);
    /// assert_eq!(edge.domain, Domain::General);
    /// ```
    fn default() -> Self {
        Self::new(
            Uuid::nil(),
            Uuid::nil(),
            EdgeType::default(),
            Domain::default(),
        )
    }
}
```

---

## Unit Tests to Add

Add these tests inside the existing `#[cfg(test)] mod tests { ... }` block, AFTER the existing `create_test_edge()` helper function.

```rust
    // =========================================================================
    // GraphEdge Method Tests (TASK-M02-011)
    // =========================================================================

    // --- new() Constructor Tests ---

    #[test]
    fn test_new_creates_edge_with_domain_nt_weights() {
        let source = Uuid::new_v4();
        let target = Uuid::new_v4();
        let edge = GraphEdge::new(source, target, EdgeType::Semantic, Domain::Code);

        let expected_nt = NeurotransmitterWeights::for_domain(Domain::Code);
        assert_eq!(edge.neurotransmitter_weights, expected_nt);
    }

    #[test]
    fn test_new_uses_edge_type_default_weight() {
        let edge = GraphEdge::new(Uuid::new_v4(), Uuid::new_v4(), EdgeType::Causal, Domain::General);
        assert_eq!(edge.weight, EdgeType::Causal.default_weight());
        assert_eq!(edge.weight, 0.8);
    }

    #[test]
    fn test_new_sets_confidence_to_half() {
        let edge = GraphEdge::new(Uuid::new_v4(), Uuid::new_v4(), EdgeType::Semantic, Domain::General);
        assert_eq!(edge.confidence, 0.5);
    }

    #[test]
    fn test_new_sets_steering_reward_to_zero() {
        let edge = GraphEdge::new(Uuid::new_v4(), Uuid::new_v4(), EdgeType::Semantic, Domain::General);
        assert_eq!(edge.steering_reward, 0.0);
    }

    #[test]
    fn test_new_sets_traversal_count_to_zero() {
        let edge = GraphEdge::new(Uuid::new_v4(), Uuid::new_v4(), EdgeType::Semantic, Domain::General);
        assert_eq!(edge.traversal_count, 0);
    }

    #[test]
    fn test_new_sets_is_amortized_shortcut_false() {
        let edge = GraphEdge::new(Uuid::new_v4(), Uuid::new_v4(), EdgeType::Semantic, Domain::General);
        assert!(!edge.is_amortized_shortcut);
    }

    #[test]
    fn test_new_sets_last_traversed_at_none() {
        let edge = GraphEdge::new(Uuid::new_v4(), Uuid::new_v4(), EdgeType::Semantic, Domain::General);
        assert!(edge.last_traversed_at.is_none());
    }

    #[test]
    fn test_new_generates_unique_id() {
        let edge1 = GraphEdge::new(Uuid::new_v4(), Uuid::new_v4(), EdgeType::Semantic, Domain::General);
        let edge2 = GraphEdge::new(Uuid::new_v4(), Uuid::new_v4(), EdgeType::Semantic, Domain::General);
        assert_ne!(edge1.id, edge2.id);
    }

    #[test]
    fn test_new_all_edge_types() {
        for edge_type in EdgeType::all() {
            let edge = GraphEdge::new(Uuid::new_v4(), Uuid::new_v4(), edge_type, Domain::General);
            assert_eq!(edge.weight, edge_type.default_weight());
        }
    }

    #[test]
    fn test_new_all_domains() {
        for domain in Domain::all() {
            let edge = GraphEdge::new(Uuid::new_v4(), Uuid::new_v4(), EdgeType::Semantic, domain);
            assert_eq!(edge.domain, domain);
            assert_eq!(edge.neurotransmitter_weights, NeurotransmitterWeights::for_domain(domain));
        }
    }

    // --- with_weight() Constructor Tests ---

    #[test]
    fn test_with_weight_sets_explicit_values() {
        let edge = GraphEdge::with_weight(
            Uuid::new_v4(), Uuid::new_v4(),
            EdgeType::Semantic, Domain::General,
            0.75, 0.95
        );
        assert_eq!(edge.weight, 0.75);
        assert_eq!(edge.confidence, 0.95);
    }

    #[test]
    fn test_with_weight_clamps_weight_high() {
        let edge = GraphEdge::with_weight(
            Uuid::new_v4(), Uuid::new_v4(),
            EdgeType::Semantic, Domain::General,
            1.5, 0.5
        );
        assert_eq!(edge.weight, 1.0);
    }

    #[test]
    fn test_with_weight_clamps_weight_low() {
        let edge = GraphEdge::with_weight(
            Uuid::new_v4(), Uuid::new_v4(),
            EdgeType::Semantic, Domain::General,
            -0.5, 0.5
        );
        assert_eq!(edge.weight, 0.0);
    }

    #[test]
    fn test_with_weight_clamps_confidence_high() {
        let edge = GraphEdge::with_weight(
            Uuid::new_v4(), Uuid::new_v4(),
            EdgeType::Semantic, Domain::General,
            0.5, 1.5
        );
        assert_eq!(edge.confidence, 1.0);
    }

    #[test]
    fn test_with_weight_clamps_confidence_low() {
        let edge = GraphEdge::with_weight(
            Uuid::new_v4(), Uuid::new_v4(),
            EdgeType::Semantic, Domain::General,
            0.5, -0.5
        );
        assert_eq!(edge.confidence, 0.0);
    }

    // --- get_modulated_weight() Tests ---

    #[test]
    fn test_get_modulated_weight_applies_nt() {
        let edge = GraphEdge::new(Uuid::new_v4(), Uuid::new_v4(), EdgeType::Semantic, Domain::General);
        // General NT: excitatory=0.5, inhibitory=0.2, modulatory=0.3
        // Base weight for Semantic: 0.5
        // NT factor: (0.5*0.5 - 0.5*0.2) * (1 + (0.3-0.5)*0.4) = 0.15 * 0.92 = 0.138
        // With steering_reward=0: 0.138 * (1 + 0*0.2) = 0.138
        let modulated = edge.get_modulated_weight();
        assert!((modulated - 0.138).abs() < 0.001, "Expected ~0.138, got {}", modulated);
    }

    #[test]
    fn test_get_modulated_weight_applies_steering_positive() {
        let mut edge = GraphEdge::new(Uuid::new_v4(), Uuid::new_v4(), EdgeType::Semantic, Domain::General);
        edge.steering_reward = 1.0;
        // NT factor ~0.138 (from above)
        // With steering_reward=1.0: 0.138 * (1 + 1.0*0.2) = 0.138 * 1.2 = 0.1656
        let modulated = edge.get_modulated_weight();
        assert!(modulated > 0.138, "Positive steering should increase weight");
    }

    #[test]
    fn test_get_modulated_weight_applies_steering_negative() {
        let mut edge = GraphEdge::new(Uuid::new_v4(), Uuid::new_v4(), EdgeType::Semantic, Domain::General);
        edge.steering_reward = -1.0;
        // NT factor ~0.138
        // With steering_reward=-1.0: 0.138 * (1 + (-1.0)*0.2) = 0.138 * 0.8 = 0.1104
        let modulated = edge.get_modulated_weight();
        assert!(modulated < 0.138, "Negative steering should decrease weight");
    }

    #[test]
    fn test_get_modulated_weight_always_in_range() {
        for domain in Domain::all() {
            for edge_type in EdgeType::all() {
                for sr in [-1.0_f32, -0.5, 0.0, 0.5, 1.0] {
                    let mut edge = GraphEdge::new(Uuid::new_v4(), Uuid::new_v4(), edge_type, domain);
                    edge.steering_reward = sr;
                    let modulated = edge.get_modulated_weight();
                    assert!(
                        modulated >= 0.0 && modulated <= 1.0,
                        "Out of range: domain={:?}, edge_type={:?}, sr={}, modulated={}",
                        domain, edge_type, sr, modulated
                    );
                }
            }
        }
    }

    // --- apply_steering_reward() Tests ---

    #[test]
    fn test_apply_steering_reward_adds() {
        let mut edge = GraphEdge::new(Uuid::new_v4(), Uuid::new_v4(), EdgeType::Semantic, Domain::General);
        edge.apply_steering_reward(0.3);
        assert_eq!(edge.steering_reward, 0.3);
        edge.apply_steering_reward(0.2);
        assert_eq!(edge.steering_reward, 0.5);
    }

    #[test]
    fn test_apply_steering_reward_clamps_positive() {
        let mut edge = GraphEdge::new(Uuid::new_v4(), Uuid::new_v4(), EdgeType::Semantic, Domain::General);
        edge.apply_steering_reward(0.8);
        edge.apply_steering_reward(0.5);
        assert_eq!(edge.steering_reward, 1.0);
    }

    #[test]
    fn test_apply_steering_reward_clamps_negative() {
        let mut edge = GraphEdge::new(Uuid::new_v4(), Uuid::new_v4(), EdgeType::Semantic, Domain::General);
        edge.apply_steering_reward(-0.8);
        edge.apply_steering_reward(-0.5);
        assert_eq!(edge.steering_reward, -1.0);
    }

    #[test]
    fn test_apply_steering_reward_handles_negative() {
        let mut edge = GraphEdge::new(Uuid::new_v4(), Uuid::new_v4(), EdgeType::Semantic, Domain::General);
        edge.apply_steering_reward(-0.5);
        assert_eq!(edge.steering_reward, -0.5);
    }

    // --- decay_steering() Tests ---

    #[test]
    fn test_decay_steering_multiplies() {
        let mut edge = GraphEdge::new(Uuid::new_v4(), Uuid::new_v4(), EdgeType::Semantic, Domain::General);
        edge.steering_reward = 1.0;
        edge.decay_steering(0.5);
        assert_eq!(edge.steering_reward, 0.5);
    }

    #[test]
    fn test_decay_steering_to_zero() {
        let mut edge = GraphEdge::new(Uuid::new_v4(), Uuid::new_v4(), EdgeType::Semantic, Domain::General);
        edge.steering_reward = 0.5;
        edge.decay_steering(0.0);
        assert_eq!(edge.steering_reward, 0.0);
    }

    #[test]
    fn test_decay_steering_negative() {
        let mut edge = GraphEdge::new(Uuid::new_v4(), Uuid::new_v4(), EdgeType::Semantic, Domain::General);
        edge.steering_reward = -1.0;
        edge.decay_steering(0.5);
        assert_eq!(edge.steering_reward, -0.5);
    }

    // --- record_traversal() Tests ---

    #[test]
    fn test_record_traversal_increments_count() {
        let mut edge = GraphEdge::new(Uuid::new_v4(), Uuid::new_v4(), EdgeType::Semantic, Domain::General);
        assert_eq!(edge.traversal_count, 0);
        edge.record_traversal();
        assert_eq!(edge.traversal_count, 1);
        edge.record_traversal();
        assert_eq!(edge.traversal_count, 2);
    }

    #[test]
    fn test_record_traversal_updates_timestamp() {
        let mut edge = GraphEdge::new(Uuid::new_v4(), Uuid::new_v4(), EdgeType::Semantic, Domain::General);
        assert!(edge.last_traversed_at.is_none());
        edge.record_traversal();
        assert!(edge.last_traversed_at.is_some());
    }

    #[test]
    fn test_record_traversal_saturates() {
        let mut edge = GraphEdge::new(Uuid::new_v4(), Uuid::new_v4(), EdgeType::Semantic, Domain::General);
        edge.traversal_count = u64::MAX;
        edge.record_traversal();
        assert_eq!(edge.traversal_count, u64::MAX);
    }

    // --- is_reliable_shortcut() Tests ---

    #[test]
    fn test_is_reliable_shortcut_all_conditions_met() {
        let mut edge = GraphEdge::new(Uuid::new_v4(), Uuid::new_v4(), EdgeType::Semantic, Domain::General);
        edge.is_amortized_shortcut = true;
        edge.traversal_count = 5;
        edge.steering_reward = 0.5;
        edge.confidence = 0.8;
        assert!(edge.is_reliable_shortcut());
    }

    #[test]
    fn test_is_reliable_shortcut_fails_not_shortcut() {
        let mut edge = GraphEdge::new(Uuid::new_v4(), Uuid::new_v4(), EdgeType::Semantic, Domain::General);
        edge.is_amortized_shortcut = false; // Fails here
        edge.traversal_count = 5;
        edge.steering_reward = 0.5;
        edge.confidence = 0.8;
        assert!(!edge.is_reliable_shortcut());
    }

    #[test]
    fn test_is_reliable_shortcut_fails_low_traversal() {
        let mut edge = GraphEdge::new(Uuid::new_v4(), Uuid::new_v4(), EdgeType::Semantic, Domain::General);
        edge.is_amortized_shortcut = true;
        edge.traversal_count = 2; // Fails here (need >= 3)
        edge.steering_reward = 0.5;
        edge.confidence = 0.8;
        assert!(!edge.is_reliable_shortcut());
    }

    #[test]
    fn test_is_reliable_shortcut_fails_low_reward() {
        let mut edge = GraphEdge::new(Uuid::new_v4(), Uuid::new_v4(), EdgeType::Semantic, Domain::General);
        edge.is_amortized_shortcut = true;
        edge.traversal_count = 5;
        edge.steering_reward = 0.2; // Fails here (need > 0.3)
        edge.confidence = 0.8;
        assert!(!edge.is_reliable_shortcut());
    }

    #[test]
    fn test_is_reliable_shortcut_fails_low_confidence() {
        let mut edge = GraphEdge::new(Uuid::new_v4(), Uuid::new_v4(), EdgeType::Semantic, Domain::General);
        edge.is_amortized_shortcut = true;
        edge.traversal_count = 5;
        edge.steering_reward = 0.5;
        edge.confidence = 0.6; // Fails here (need >= 0.7)
        assert!(!edge.is_reliable_shortcut());
    }

    #[test]
    fn test_is_reliable_shortcut_boundary_traversal() {
        let mut edge = GraphEdge::new(Uuid::new_v4(), Uuid::new_v4(), EdgeType::Semantic, Domain::General);
        edge.is_amortized_shortcut = true;
        edge.traversal_count = 3; // Exactly 3
        edge.steering_reward = 0.5;
        edge.confidence = 0.8;
        assert!(edge.is_reliable_shortcut());
    }

    #[test]
    fn test_is_reliable_shortcut_boundary_reward() {
        let mut edge = GraphEdge::new(Uuid::new_v4(), Uuid::new_v4(), EdgeType::Semantic, Domain::General);
        edge.is_amortized_shortcut = true;
        edge.traversal_count = 5;
        edge.steering_reward = 0.3; // Exactly 0.3 - should FAIL (need > 0.3)
        edge.confidence = 0.8;
        assert!(!edge.is_reliable_shortcut());
    }

    #[test]
    fn test_is_reliable_shortcut_boundary_confidence() {
        let mut edge = GraphEdge::new(Uuid::new_v4(), Uuid::new_v4(), EdgeType::Semantic, Domain::General);
        edge.is_amortized_shortcut = true;
        edge.traversal_count = 5;
        edge.steering_reward = 0.5;
        edge.confidence = 0.7; // Exactly 0.7
        assert!(edge.is_reliable_shortcut());
    }

    // --- mark_as_shortcut() Tests ---

    #[test]
    fn test_mark_as_shortcut() {
        let mut edge = GraphEdge::new(Uuid::new_v4(), Uuid::new_v4(), EdgeType::Semantic, Domain::General);
        assert!(!edge.is_amortized_shortcut);
        edge.mark_as_shortcut();
        assert!(edge.is_amortized_shortcut);
    }

    #[test]
    fn test_mark_as_shortcut_idempotent() {
        let mut edge = GraphEdge::new(Uuid::new_v4(), Uuid::new_v4(), EdgeType::Semantic, Domain::General);
        edge.mark_as_shortcut();
        edge.mark_as_shortcut();
        assert!(edge.is_amortized_shortcut);
    }

    // --- age_seconds() Tests ---

    #[test]
    fn test_age_seconds_non_negative() {
        let edge = GraphEdge::new(Uuid::new_v4(), Uuid::new_v4(), EdgeType::Semantic, Domain::General);
        assert!(edge.age_seconds() >= 0);
    }

    #[test]
    fn test_age_seconds_increases() {
        let edge = GraphEdge::new(Uuid::new_v4(), Uuid::new_v4(), EdgeType::Semantic, Domain::General);
        let age1 = edge.age_seconds();
        std::thread::sleep(std::time::Duration::from_millis(10));
        let age2 = edge.age_seconds();
        assert!(age2 >= age1);
    }

    // --- Default Trait Tests ---

    #[test]
    fn test_default_uses_nil_uuids() {
        let edge = GraphEdge::default();
        assert_eq!(edge.source_id, Uuid::nil());
        assert_eq!(edge.target_id, Uuid::nil());
    }

    #[test]
    fn test_default_uses_semantic_edge_type() {
        let edge = GraphEdge::default();
        assert_eq!(edge.edge_type, EdgeType::Semantic);
    }

    #[test]
    fn test_default_uses_general_domain() {
        let edge = GraphEdge::default();
        assert_eq!(edge.domain, Domain::General);
    }

    #[test]
    fn test_default_has_valid_nt_weights() {
        let edge = GraphEdge::default();
        assert!(edge.neurotransmitter_weights.validate());
    }

    #[test]
    fn test_default_weight_matches_semantic() {
        let edge = GraphEdge::default();
        assert_eq!(edge.weight, EdgeType::Semantic.default_weight());
    }
```

---

## Verification Commands

```bash
# 1. Build (must succeed with 0 errors)
cargo build --package context-graph-core

# 2. Run all graph_edge tests (should show ~80+ tests passing)
cargo test --package context-graph-core graph_edge -- --nocapture

# 3. Clippy (must show 0 warnings)
cargo clippy --package context-graph-core -- -D warnings

# 4. Doc tests (must pass)
cargo test --package context-graph-core --doc
```

---

## Full State Verification Protocol

After implementing the logic, you MUST perform:

### 1. Source of Truth Verification
The Source of Truth is `crates/context-graph-core/src/types/graph_edge.rs`.

**Verify impl block exists:**
```bash
grep -n "impl GraphEdge" crates/context-graph-core/src/types/graph_edge.rs
```
Expected output: Line number showing `impl GraphEdge {`

**Verify all 8 methods exist:**
```bash
grep -E "^\s+pub fn (new|with_weight|get_modulated_weight|apply_steering_reward|decay_steering|record_traversal|is_reliable_shortcut|mark_as_shortcut|age_seconds)" crates/context-graph-core/src/types/graph_edge.rs
```
Expected: 9 lines (new, with_weight, get_modulated_weight, apply_steering_reward, decay_steering, record_traversal, is_reliable_shortcut, mark_as_shortcut, age_seconds)

**Verify Default impl exists:**
```bash
grep -n "impl Default for GraphEdge" crates/context-graph-core/src/types/graph_edge.rs
```

### 2. Execute & Inspect Test Results
```bash
cargo test --package context-graph-core graph_edge -- --nocapture 2>&1 | tee /tmp/graph_edge_tests.log
grep -E "^test.*ok$|^test.*FAILED$" /tmp/graph_edge_tests.log | wc -l
```
Expected: 80+ tests, 0 failures

### 3. Boundary & Edge Case Audit

**Edge Case 1: Empty/Zero values**
```bash
cargo test --package context-graph-core test_get_modulated_weight_applies_nt -- --nocapture
```
Verify: Output shows modulated weight ~0.138 for General domain Semantic edge.

**Edge Case 2: Maximum saturation**
```bash
cargo test --package context-graph-core test_record_traversal_saturates -- --nocapture
```
Verify: traversal_count stays at u64::MAX after increment.

**Edge Case 3: Boundary conditions for is_reliable_shortcut**
```bash
cargo test --package context-graph-core is_reliable_shortcut -- --nocapture
```
Verify: All 8 reliability tests pass, especially boundary tests.

### 4. Evidence of Success Log
After all tests pass, generate evidence:
```bash
echo "=== TASK-M02-011 VERIFICATION LOG ===" > /tmp/task_m02_011_evidence.log
echo "Timestamp: $(date -u +%Y-%m-%dT%H:%M:%SZ)" >> /tmp/task_m02_011_evidence.log
echo "" >> /tmp/task_m02_011_evidence.log

echo "=== Build Result ===" >> /tmp/task_m02_011_evidence.log
cargo build --package context-graph-core 2>&1 | tail -5 >> /tmp/task_m02_011_evidence.log

echo "" >> /tmp/task_m02_011_evidence.log
echo "=== Test Summary ===" >> /tmp/task_m02_011_evidence.log
cargo test --package context-graph-core graph_edge 2>&1 | grep -E "^test result:|passed|failed" >> /tmp/task_m02_011_evidence.log

echo "" >> /tmp/task_m02_011_evidence.log
echo "=== Clippy Result ===" >> /tmp/task_m02_011_evidence.log
cargo clippy --package context-graph-core -- -D warnings 2>&1 | tail -3 >> /tmp/task_m02_011_evidence.log

echo "" >> /tmp/task_m02_011_evidence.log
echo "=== Method Count Verification ===" >> /tmp/task_m02_011_evidence.log
grep -c "pub fn" crates/context-graph-core/src/types/graph_edge.rs >> /tmp/task_m02_011_evidence.log

cat /tmp/task_m02_011_evidence.log
```

---

## Sherlock-Holmes Final Verification

After completing all implementation, you MUST spawn a sherlock-holmes subagent to verify:

1. All 9 methods exist and have correct signatures
2. All tests pass (80+ tests expected)
3. No clippy warnings
4. Documentation compiles
5. No backwards compatibility hacks introduced
6. All edge cases properly handled (especially boundary values)
7. Formula implementations match constitution.yaml exactly

If Sherlock-Holmes identifies ANY issues, fix them before marking complete.

---

## Anti-Patterns to Avoid (Constitution Violations)

- **AP-001**: Never use `unwrap()` in any method - use `.expect()` with context if needed
- **AP-003**: No magic numbers - all thresholds (0.3, 0.7, 3) are documented in comments
- **AP-009**: Always clamp outputs to valid ranges, never allow NaN/Infinity
- **AP-007**: No stub data - tests use real constructed objects

---

## Success Criteria

| Criterion | Requirement |
|-----------|-------------|
| Build | `cargo build` succeeds with 0 errors |
| Tests | 80+ graph_edge tests pass |
| Clippy | 0 warnings with `-D warnings` |
| Methods | All 9 methods exist with correct signatures |
| Default | `impl Default for GraphEdge` exists |
| Coverage | All validation criteria from original spec met |

---

*Task ID: TASK-M02-011*
*Module: 02 - Core Infrastructure*
*Layer: Foundation*
*Version: 2.0 (Audited against codebase 2025-12-31)*
