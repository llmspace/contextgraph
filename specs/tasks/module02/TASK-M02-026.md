# TASK-M02-026: Implement Memex Trait Abstraction

## Status: READY
**Dependencies VERIFIED COMPLETE**: TASK-M02-017, TASK-M02-018, TASK-M02-023, TASK-M02-024, TASK-M02-025

---

## Context for AI Agent

You are implementing a **synchronous** storage abstraction trait called `Memex` that `RocksDbMemex` will implement. This enables future backends (in-memory for testing, distributed for scale) and dependency injection patterns.

### Critical Facts
1. **NOT async** - Current codebase uses synchronous RocksDB operations. Do NOT use `async_trait`.
2. **Modular structure** - RocksDB backend is in `crates/context-graph-storage/src/rocksdb_backend/` (directory, not single file).
3. **Methods already exist** - All CRUD methods exist on `RocksDbMemex`, you're extracting them into a trait.
4. **NO mock data in tests** - Tests must use real `RocksDbMemex` instances with `tempfile::TempDir`.

---

## Current Codebase State (VERIFIED 2025-12-31)

### File Structure
```
crates/context-graph-storage/src/
├── lib.rs                    # Crate root, re-exports
├── memex.rs                  # STUB - needs trait implementation
├── column_families.rs        # CF definitions (12 CFs)
├── serialization.rs          # Bincode/msgpack serialization
├── indexes.rs                # Index trait (unused placeholder)
└── rocksdb_backend/
    ├── mod.rs                # Module exports
    ├── config.rs             # RocksDbConfig struct
    ├── core.rs               # RocksDbMemex struct, open/close/health
    ├── error.rs              # StorageError enum (10 variants)
    ├── helpers.rs            # Key formatting utilities
    ├── node_ops.rs           # store_node, get_node, update_node, delete_node
    ├── edge_ops.rs           # store_edge, get_edge, update_edge, delete_edge, get_edges_from, get_edges_to
    ├── embedding_ops.rs      # store_embedding, get_embedding, batch_get_embeddings, delete_embedding, embedding_exists
    ├── index_ops.rs          # get_nodes_by_quadrant, get_nodes_by_tag, get_nodes_by_source, get_nodes_in_time_range
    └── tests_*.rs            # 8 test modules
```

### Existing RocksDbMemex Methods (ALL SYNCHRONOUS)
From `node_ops.rs`:
- `store_node(&self, node: &MemoryNode) -> Result<(), StorageError>`
- `get_node(&self, id: &NodeId) -> Result<MemoryNode, StorageError>`
- `update_node(&self, node: &MemoryNode) -> Result<(), StorageError>`
- `delete_node(&self, id: &NodeId, soft_delete: bool) -> Result<(), StorageError>`

From `edge_ops.rs`:
- `store_edge(&self, edge: &GraphEdge) -> Result<(), StorageError>`
- `get_edge(&self, source_id: &NodeId, target_id: &NodeId, edge_type: EdgeType) -> Result<GraphEdge, StorageError>`
- `update_edge(&self, edge: &GraphEdge) -> Result<(), StorageError>`
- `delete_edge(&self, source_id: &NodeId, target_id: &NodeId, edge_type: EdgeType) -> Result<(), StorageError>`
- `get_edges_from(&self, source_id: &NodeId) -> Result<Vec<GraphEdge>, StorageError>`
- `get_edges_to(&self, target_id: &NodeId) -> Result<Vec<GraphEdge>, StorageError>`

From `index_ops.rs`:
- `get_nodes_by_quadrant(&self, quadrant: JohariQuadrant, limit: Option<usize>, offset: usize) -> Result<Vec<NodeId>, StorageError>`
- `get_nodes_by_tag(&self, tag: &str, limit: Option<usize>, offset: usize) -> Result<Vec<NodeId>, StorageError>`

From `embedding_ops.rs`:
- `get_embedding(&self, node_id: &NodeId) -> Result<EmbeddingVector, StorageError>`

From `core.rs`:
- `health_check(&self) -> Result<(), StorageError>`

---

## Implementation Requirements

### 1. Create Memex Trait in `crates/context-graph-storage/src/memex.rs`

Replace the current stub with:

```rust
//! Memex storage trait abstraction.
//!
//! The Memex trait defines the storage contract for MemoryNode and GraphEdge
//! persistence. Named after Vannevar Bush's conceptual memory machine.
//!
//! # Implementors
//! - `RocksDbMemex`: Production RocksDB implementation
//!
//! # Constitution Reference
//! - SEC-06: All delete operations must be soft deletes with 30-day recovery
//! - AP-010: store_memory requires rationale

use context_graph_core::marblestone::EdgeType;
use context_graph_core::types::{
    EmbeddingVector, GraphEdge, JohariQuadrant, MemoryNode, NodeId,
};

use crate::rocksdb_backend::StorageError;

/// Storage health status.
///
/// Returned by `Memex::health_check()` to provide storage metrics.
#[derive(Debug, Clone, PartialEq)]
pub struct StorageHealth {
    /// Whether storage is operational
    pub is_healthy: bool,
    /// Approximate number of nodes (may be estimate)
    pub node_count: u64,
    /// Approximate number of edges (may be estimate)
    pub edge_count: u64,
    /// Approximate storage size in bytes
    pub storage_bytes: u64,
}

impl Default for StorageHealth {
    fn default() -> Self {
        Self {
            is_healthy: true,
            node_count: 0,
            edge_count: 0,
            storage_bytes: 0,
        }
    }
}

/// Storage abstraction trait for the Context Graph system.
///
/// This trait defines the core storage operations required by the system.
/// RocksDbMemex implements this trait, enabling:
/// 1. **Testing**: In-memory implementation for fast unit tests
/// 2. **Flexibility**: Future distributed storage backends
/// 3. **Mocking**: Easy to mock for integration tests
/// 4. **Dependency Injection**: Higher layers depend on trait, not concrete type
///
/// # Object Safety
/// This trait is object-safe and can be used with `dyn Memex`.
/// All methods take `&self` and return concrete types (no generics, no `Self` in return).
///
/// # Thread Safety
/// Implementors MUST be `Send + Sync` for cross-thread usage.
pub trait Memex: Send + Sync {
    // === Node Operations ===

    /// Stores a memory node.
    ///
    /// Validates node before storage. Writes atomically to all relevant
    /// column families (nodes, embeddings, johari, temporal, tags, sources).
    ///
    /// # Errors
    /// - `StorageError::ValidationFailed` if node.validate() fails
    /// - `StorageError::Serialization` if serialization fails
    /// - `StorageError::WriteFailed` if storage write fails
    fn store_node(&self, node: &MemoryNode) -> Result<(), StorageError>;

    /// Retrieves a memory node by ID.
    ///
    /// # Errors
    /// - `StorageError::NotFound` if node doesn't exist
    /// - `StorageError::Serialization` if deserialization fails
    fn get_node(&self, id: &NodeId) -> Result<MemoryNode, StorageError>;

    /// Updates an existing memory node.
    ///
    /// Maintains index consistency when quadrant or tags change.
    /// DOES NOT create if node doesn't exist.
    ///
    /// # Errors
    /// - `StorageError::NotFound` if node doesn't exist
    /// - `StorageError::ValidationFailed` if node.validate() fails
    fn update_node(&self, node: &MemoryNode) -> Result<(), StorageError>;

    /// Deletes a memory node.
    ///
    /// # Arguments
    /// * `id` - Node ID to delete
    /// * `soft_delete` - If true, marks as deleted (SEC-06); if false, permanently removes
    ///
    /// # Errors
    /// - `StorageError::NotFound` if node doesn't exist
    fn delete_node(&self, id: &NodeId, soft_delete: bool) -> Result<(), StorageError>;

    // === Edge Operations ===

    /// Stores a graph edge.
    ///
    /// # Errors
    /// - `StorageError::Serialization` if serialization fails
    /// - `StorageError::WriteFailed` if storage write fails
    fn store_edge(&self, edge: &GraphEdge) -> Result<(), StorageError>;

    /// Retrieves a graph edge by composite key.
    ///
    /// # Errors
    /// - `StorageError::NotFound` if edge doesn't exist
    fn get_edge(
        &self,
        source_id: &NodeId,
        target_id: &NodeId,
        edge_type: EdgeType,
    ) -> Result<GraphEdge, StorageError>;

    /// Gets all outgoing edges from a node.
    ///
    /// Uses prefix scan for efficiency.
    fn get_edges_from(&self, source_id: &NodeId) -> Result<Vec<GraphEdge>, StorageError>;

    /// Gets all incoming edges to a node.
    ///
    /// Note: Full scan - less efficient than get_edges_from.
    fn get_edges_to(&self, target_id: &NodeId) -> Result<Vec<GraphEdge>, StorageError>;

    // === Query Operations ===

    /// Queries nodes by Johari quadrant.
    ///
    /// # Arguments
    /// * `quadrant` - The Johari quadrant to query
    /// * `limit` - Maximum results (None = unlimited)
    fn query_by_quadrant(
        &self,
        quadrant: JohariQuadrant,
        limit: Option<usize>,
    ) -> Result<Vec<NodeId>, StorageError>;

    /// Queries nodes by tag.
    ///
    /// # Arguments
    /// * `tag` - Tag to search for (exact match)
    /// * `limit` - Maximum results (None = unlimited)
    fn query_by_tag(
        &self,
        tag: &str,
        limit: Option<usize>,
    ) -> Result<Vec<NodeId>, StorageError>;

    // === Embedding Operations ===

    /// Retrieves an embedding by node ID.
    ///
    /// # Errors
    /// - `StorageError::NotFound` if no embedding for this node
    fn get_embedding(&self, id: &NodeId) -> Result<EmbeddingVector, StorageError>;

    // === Health ===

    /// Checks storage health and returns metrics.
    ///
    /// Should verify all storage components are accessible.
    fn health_check(&self) -> Result<StorageHealth, StorageError>;
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::RocksDbMemex;
    use tempfile::TempDir;

    #[test]
    fn test_trait_object_safe() {
        // Verify trait is object-safe by creating Box<dyn Memex>
        let tmp = TempDir::new().expect("create temp dir");
        let db = RocksDbMemex::open(tmp.path()).expect("open db");

        // This line compiles only if trait is object-safe
        let _boxed: Box<dyn Memex> = Box::new(db);

        println!("=== TRAIT OBJECT SAFETY TEST ===");
        println!("RESULT: Box<dyn Memex> created successfully");
        println!("PROOF: Trait is object-safe");
    }

    #[test]
    fn test_storage_health_default() {
        let health = StorageHealth::default();
        assert!(health.is_healthy);
        assert_eq!(health.node_count, 0);
        assert_eq!(health.edge_count, 0);
        assert_eq!(health.storage_bytes, 0);
    }

    #[test]
    fn test_storage_health_debug_clone() {
        let health = StorageHealth {
            is_healthy: true,
            node_count: 100,
            edge_count: 50,
            storage_bytes: 1024,
        };

        let cloned = health.clone();
        assert_eq!(health, cloned);

        let debug = format!("{:?}", health);
        assert!(debug.contains("is_healthy: true"));
        assert!(debug.contains("node_count: 100"));
    }
}
```

### 2. Implement Memex for RocksDbMemex

Add a new file `crates/context-graph-storage/src/rocksdb_backend/memex_impl.rs`:

```rust
//! Memex trait implementation for RocksDbMemex.
//!
//! Delegates to existing methods while providing trait abstraction.

use context_graph_core::marblestone::EdgeType;
use context_graph_core::types::{
    EmbeddingVector, GraphEdge, JohariQuadrant, MemoryNode, NodeId,
};

use crate::memex::{Memex, StorageHealth};
use crate::rocksdb_backend::StorageError;
use crate::column_families::cf_names;

use super::core::RocksDbMemex;

impl Memex for RocksDbMemex {
    fn store_node(&self, node: &MemoryNode) -> Result<(), StorageError> {
        // Delegate to existing implementation in node_ops.rs
        RocksDbMemex::store_node(self, node)
    }

    fn get_node(&self, id: &NodeId) -> Result<MemoryNode, StorageError> {
        RocksDbMemex::get_node(self, id)
    }

    fn update_node(&self, node: &MemoryNode) -> Result<(), StorageError> {
        RocksDbMemex::update_node(self, node)
    }

    fn delete_node(&self, id: &NodeId, soft_delete: bool) -> Result<(), StorageError> {
        RocksDbMemex::delete_node(self, id, soft_delete)
    }

    fn store_edge(&self, edge: &GraphEdge) -> Result<(), StorageError> {
        RocksDbMemex::store_edge(self, edge)
    }

    fn get_edge(
        &self,
        source_id: &NodeId,
        target_id: &NodeId,
        edge_type: EdgeType,
    ) -> Result<GraphEdge, StorageError> {
        RocksDbMemex::get_edge(self, source_id, target_id, edge_type)
    }

    fn get_edges_from(&self, source_id: &NodeId) -> Result<Vec<GraphEdge>, StorageError> {
        RocksDbMemex::get_edges_from(self, source_id)
    }

    fn get_edges_to(&self, target_id: &NodeId) -> Result<Vec<GraphEdge>, StorageError> {
        RocksDbMemex::get_edges_to(self, target_id)
    }

    fn query_by_quadrant(
        &self,
        quadrant: JohariQuadrant,
        limit: Option<usize>,
    ) -> Result<Vec<NodeId>, StorageError> {
        // Delegate to index_ops with offset=0
        self.get_nodes_by_quadrant(quadrant, limit, 0)
    }

    fn query_by_tag(
        &self,
        tag: &str,
        limit: Option<usize>,
    ) -> Result<Vec<NodeId>, StorageError> {
        // Delegate to index_ops with offset=0
        self.get_nodes_by_tag(tag, limit, 0)
    }

    fn get_embedding(&self, id: &NodeId) -> Result<EmbeddingVector, StorageError> {
        RocksDbMemex::get_embedding(self, id)
    }

    fn health_check(&self) -> Result<StorageHealth, StorageError> {
        // First verify all CFs accessible (existing health_check)
        RocksDbMemex::health_check(self)?;

        // Get approximate counts from RocksDB properties
        let node_count = self.get_approximate_count(cf_names::NODES)?;
        let edge_count = self.get_approximate_count(cf_names::EDGES)?;

        // Get storage size
        let storage_bytes = self.get_storage_size()?;

        Ok(StorageHealth {
            is_healthy: true,
            node_count,
            edge_count,
            storage_bytes,
        })
    }
}

impl RocksDbMemex {
    /// Get approximate key count for a column family.
    fn get_approximate_count(&self, cf_name: &str) -> Result<u64, StorageError> {
        let cf = self.get_cf(cf_name)?;

        // RocksDB estimate-num-keys property
        let count = self.db
            .property_int_value_cf(cf, "rocksdb.estimate-num-keys")
            .ok()
            .flatten()
            .unwrap_or(0);

        Ok(count)
    }

    /// Get total storage size across all column families.
    fn get_storage_size(&self) -> Result<u64, StorageError> {
        let mut total_bytes = 0u64;

        for cf_name in cf_names::ALL {
            let cf = self.get_cf(cf_name)?;

            // Get SST file size for this CF
            if let Some(size) = self.db
                .property_int_value_cf(cf, "rocksdb.total-sst-files-size")
                .ok()
                .flatten()
            {
                total_bytes += size;
            }
        }

        Ok(total_bytes)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::RocksDbMemex;
    use context_graph_core::types::{GraphEdge, MemoryNode};
    use tempfile::TempDir;

    fn create_test_db() -> (RocksDbMemex, TempDir) {
        let tmp = TempDir::new().expect("create temp dir");
        let db = RocksDbMemex::open(tmp.path()).expect("open db");
        (db, tmp)
    }

    fn create_test_node() -> MemoryNode {
        MemoryNode::new("Test content for Memex trait".to_string())
    }

    fn create_test_edge(source: NodeId, target: NodeId) -> GraphEdge {
        GraphEdge::new(source, target, EdgeType::Semantic)
    }

    // ========== NODE OPERATIONS VIA TRAIT ==========

    #[test]
    fn test_memex_store_and_get_node() {
        let (db, _tmp) = create_test_db();
        let memex: &dyn Memex = &db;

        let node = create_test_node();
        let node_id = node.id;

        println!("=== MEMEX NODE STORE/GET TEST ===");
        println!("BEFORE: Node ID = {}", node_id);

        // Store via trait
        memex.store_node(&node).expect("store via Memex");

        // Retrieve via trait
        let retrieved = memex.get_node(&node_id).expect("get via Memex");

        println!("AFTER: Retrieved node ID = {}", retrieved.id);
        println!("AFTER: Content = '{}'", retrieved.content);

        assert_eq!(retrieved.id, node_id);
        assert_eq!(retrieved.content, node.content);
        println!("RESULT: PASS - Node round-trip via Memex trait");
    }

    #[test]
    fn test_memex_update_node() {
        let (db, _tmp) = create_test_db();
        let memex: &dyn Memex = &db;

        let mut node = create_test_node();
        let node_id = node.id;

        memex.store_node(&node).expect("store");

        println!("=== MEMEX NODE UPDATE TEST ===");
        println!("BEFORE: importance = {}", node.importance);

        node.importance = 0.9;
        memex.update_node(&node).expect("update via Memex");

        let updated = memex.get_node(&node_id).expect("get");

        println!("AFTER: importance = {}", updated.importance);
        assert!((updated.importance - 0.9).abs() < 0.001);
        println!("RESULT: PASS - Node updated via Memex trait");
    }

    #[test]
    fn test_memex_delete_node() {
        let (db, _tmp) = create_test_db();
        let memex: &dyn Memex = &db;

        let node = create_test_node();
        let node_id = node.id;

        memex.store_node(&node).expect("store");

        println!("=== MEMEX NODE DELETE TEST ===");
        println!("BEFORE: Node exists = true");

        // Soft delete
        memex.delete_node(&node_id, true).expect("delete via Memex");

        // Node still exists but marked deleted
        let deleted = memex.get_node(&node_id).expect("get deleted");

        println!("AFTER: metadata.deleted = {:?}", deleted.metadata.deleted);
        assert!(deleted.metadata.deleted.is_some());
        println!("RESULT: PASS - Node soft-deleted via Memex trait");
    }

    // ========== EDGE OPERATIONS VIA TRAIT ==========

    #[test]
    fn test_memex_store_and_get_edge() {
        let (db, _tmp) = create_test_db();
        let memex: &dyn Memex = &db;

        let node1 = create_test_node();
        let node2 = create_test_node();
        memex.store_node(&node1).expect("store node1");
        memex.store_node(&node2).expect("store node2");

        let edge = create_test_edge(node1.id, node2.id);

        println!("=== MEMEX EDGE STORE/GET TEST ===");
        println!("BEFORE: Edge {} -> {}", node1.id, node2.id);

        memex.store_edge(&edge).expect("store via Memex");

        let retrieved = memex.get_edge(&node1.id, &node2.id, EdgeType::Semantic)
            .expect("get via Memex");

        println!("AFTER: Retrieved edge source = {}", retrieved.source_id);
        println!("AFTER: Retrieved edge target = {}", retrieved.target_id);

        assert_eq!(retrieved.source_id, node1.id);
        assert_eq!(retrieved.target_id, node2.id);
        println!("RESULT: PASS - Edge round-trip via Memex trait");
    }

    #[test]
    fn test_memex_get_edges_from() {
        let (db, _tmp) = create_test_db();
        let memex: &dyn Memex = &db;

        let source = create_test_node();
        let target1 = create_test_node();
        let target2 = create_test_node();

        memex.store_node(&source).expect("store source");
        memex.store_node(&target1).expect("store target1");
        memex.store_node(&target2).expect("store target2");

        memex.store_edge(&create_test_edge(source.id, target1.id)).expect("store edge1");
        memex.store_edge(&GraphEdge::new(source.id, target2.id, EdgeType::Temporal))
            .expect("store edge2");

        println!("=== MEMEX GET_EDGES_FROM TEST ===");

        let edges = memex.get_edges_from(&source.id).expect("get_edges_from via Memex");

        println!("RESULT: Found {} outgoing edges", edges.len());
        assert_eq!(edges.len(), 2);
        println!("RESULT: PASS - get_edges_from works via Memex trait");
    }

    #[test]
    fn test_memex_get_edges_to() {
        let (db, _tmp) = create_test_db();
        let memex: &dyn Memex = &db;

        let source1 = create_test_node();
        let source2 = create_test_node();
        let target = create_test_node();

        memex.store_node(&source1).expect("store source1");
        memex.store_node(&source2).expect("store source2");
        memex.store_node(&target).expect("store target");

        memex.store_edge(&create_test_edge(source1.id, target.id)).expect("store edge1");
        memex.store_edge(&create_test_edge(source2.id, target.id)).expect("store edge2");

        println!("=== MEMEX GET_EDGES_TO TEST ===");

        let edges = memex.get_edges_to(&target.id).expect("get_edges_to via Memex");

        println!("RESULT: Found {} incoming edges", edges.len());
        assert_eq!(edges.len(), 2);
        println!("RESULT: PASS - get_edges_to works via Memex trait");
    }

    // ========== QUERY OPERATIONS VIA TRAIT ==========

    #[test]
    fn test_memex_query_by_quadrant() {
        let (db, _tmp) = create_test_db();
        let memex: &dyn Memex = &db;

        let mut node = create_test_node();
        node.quadrant = JohariQuadrant::Open;
        memex.store_node(&node).expect("store");

        println!("=== MEMEX QUERY_BY_QUADRANT TEST ===");

        let open_nodes = memex.query_by_quadrant(JohariQuadrant::Open, Some(10))
            .expect("query via Memex");

        println!("RESULT: Found {} nodes in Open quadrant", open_nodes.len());
        assert!(open_nodes.contains(&node.id));
        println!("RESULT: PASS - query_by_quadrant works via Memex trait");
    }

    #[test]
    fn test_memex_query_by_tag() {
        let (db, _tmp) = create_test_db();
        let memex: &dyn Memex = &db;

        let mut node = create_test_node();
        node.metadata.tags.push("memex-test".to_string());
        memex.store_node(&node).expect("store");

        println!("=== MEMEX QUERY_BY_TAG TEST ===");

        let tagged = memex.query_by_tag("memex-test", Some(10))
            .expect("query via Memex");

        println!("RESULT: Found {} nodes with tag 'memex-test'", tagged.len());
        assert!(tagged.contains(&node.id));
        println!("RESULT: PASS - query_by_tag works via Memex trait");
    }

    // ========== EMBEDDING OPERATIONS VIA TRAIT ==========

    #[test]
    fn test_memex_get_embedding() {
        let (db, _tmp) = create_test_db();
        let memex: &dyn Memex = &db;

        let node = create_test_node();
        memex.store_node(&node).expect("store");

        println!("=== MEMEX GET_EMBEDDING TEST ===");

        let embedding = memex.get_embedding(&node.id).expect("get via Memex");

        println!("RESULT: Embedding dimensions = {}", embedding.len());
        assert_eq!(embedding.len(), 1536);
        println!("RESULT: PASS - get_embedding works via Memex trait");
    }

    // ========== HEALTH CHECK VIA TRAIT ==========

    #[test]
    fn test_memex_health_check() {
        let (db, _tmp) = create_test_db();
        let memex: &dyn Memex = &db;

        // Store some data first
        let node = create_test_node();
        memex.store_node(&node).expect("store");

        println!("=== MEMEX HEALTH_CHECK TEST ===");

        let health = memex.health_check().expect("health_check via Memex");

        println!("RESULT: is_healthy = {}", health.is_healthy);
        println!("RESULT: node_count = {}", health.node_count);
        println!("RESULT: edge_count = {}", health.edge_count);
        println!("RESULT: storage_bytes = {}", health.storage_bytes);

        assert!(health.is_healthy);
        // Note: RocksDB estimates may not be exact immediately after writes
        println!("RESULT: PASS - health_check returns StorageHealth via Memex trait");
    }

    // ========== EDGE CASES ==========

    #[test]
    fn edge_case_not_found_via_trait() {
        let (db, _tmp) = create_test_db();
        let memex: &dyn Memex = &db;

        let fake_id = uuid::Uuid::new_v4();

        println!("=== EDGE CASE: NotFound via trait ===");
        println!("BEFORE: Querying non-existent node {}", fake_id);

        let result = memex.get_node(&fake_id);

        println!("AFTER: Result = {:?}", result.is_err());
        assert!(matches!(result, Err(StorageError::NotFound { .. })));
        println!("RESULT: PASS - NotFound error propagates correctly");
    }

    #[test]
    fn edge_case_empty_query_results() {
        let (db, _tmp) = create_test_db();
        let memex: &dyn Memex = &db;

        println!("=== EDGE CASE: Empty query results ===");

        let nodes = memex.query_by_tag("nonexistent-tag-xyz", None)
            .expect("query should succeed");

        println!("RESULT: nodes.len() = {}", nodes.len());
        assert!(nodes.is_empty());
        println!("RESULT: PASS - Empty results return Ok(Vec::new())");
    }

    #[test]
    fn edge_case_limit_zero() {
        let (db, _tmp) = create_test_db();
        let memex: &dyn Memex = &db;

        let node = create_test_node();
        memex.store_node(&node).expect("store");

        println!("=== EDGE CASE: limit = Some(0) ===");

        let nodes = memex.query_by_quadrant(JohariQuadrant::Unknown, Some(0))
            .expect("query should succeed");

        println!("RESULT: nodes.len() = {}", nodes.len());
        assert!(nodes.is_empty());
        println!("RESULT: PASS - limit=0 returns empty Vec");
    }
}
```

### 3. Update Module Structure

**In `crates/context-graph-storage/src/rocksdb_backend/mod.rs`**, add:
```rust
mod memex_impl;
```

**In `crates/context-graph-storage/src/lib.rs`**, add re-export:
```rust
// Re-export Memex trait and StorageHealth
pub use memex::{Memex, StorageHealth};
```

---

## Validation Commands

```bash
# Build (must succeed)
cargo build --package context-graph-storage

# Run memex tests specifically (must pass)
cargo test --package context-graph-storage memex -- --nocapture

# Run all storage tests (must pass)
cargo test --package context-graph-storage -- --nocapture

# Check clippy (0 warnings required)
cargo clippy --package context-graph-storage -- -D warnings
```

---

## Full State Verification (MANDATORY)

After implementing the logic, you MUST perform these verification steps:

### 1. Source of Truth Identification
- **Trait definition**: `crates/context-graph-storage/src/memex.rs`
- **Trait implementation**: `crates/context-graph-storage/src/rocksdb_backend/memex_impl.rs`
- **Re-exports**: `crates/context-graph-storage/src/lib.rs`
- **Verification**: RocksDB database created in `tempfile::TempDir` during tests

### 2. Execute & Inspect
Run the tests and verify:
```bash
# Run with full output
cargo test --package context-graph-storage memex -- --nocapture 2>&1 | tee /tmp/memex_test_output.txt

# Verify test count
grep -c "test result: ok" /tmp/memex_test_output.txt
```

### 3. Boundary & Edge Case Audit (3 MANDATORY)

**Edge Case 1: Object Safety**
```rust
// In test: Must compile Box<dyn Memex>
let _boxed: Box<dyn Memex> = Box::new(db);
```
- Print BEFORE: "Attempting to create Box<dyn Memex>"
- Print AFTER: "Box<dyn Memex> created successfully"
- This proves trait is object-safe

**Edge Case 2: NotFound Error Propagation**
```rust
// Query non-existent node via trait
let result = memex.get_node(&fake_id);
assert!(matches!(result, Err(StorageError::NotFound { .. })));
```
- Print BEFORE: "Querying non-existent node {id}"
- Print AFTER: "Result = {:?}", result.is_err()
- This proves errors propagate through trait

**Edge Case 3: Empty Results vs Error**
```rust
// Query with no matches
let nodes = memex.query_by_tag("nonexistent-tag", None)?;
assert!(nodes.is_empty());
```
- Print BEFORE: "Querying tag that doesn't exist"
- Print AFTER: "nodes.len() = {}"
- This proves empty results return Ok(Vec::new()), not errors

### 4. Evidence of Success
After running tests, verify:
```bash
# Show test results
grep -E "(PASS|RESULT)" /tmp/memex_test_output.txt

# Count passing tests
grep -c "ok$" /tmp/memex_test_output.txt

# Verify no failures
! grep -q "FAILED" /tmp/memex_test_output.txt && echo "NO FAILURES"
```

---

## Definition of Done Checklist

- [ ] `Memex` trait defined in `memex.rs` with all 12 methods
- [ ] `StorageHealth` struct defined with 4 fields + Default + Debug + Clone + PartialEq
- [ ] `impl Memex for RocksDbMemex` complete in `memex_impl.rs`
- [ ] All trait methods delegate to existing `RocksDbMemex` methods
- [ ] `health_check()` returns `StorageHealth` with actual metrics
- [ ] Trait is object-safe (test creates `Box<dyn Memex>`)
- [ ] `cargo build --package context-graph-storage` succeeds
- [ ] All memex tests pass with `--nocapture` showing verification output
- [ ] `cargo clippy -- -D warnings` reports 0 warnings
- [ ] Re-exports added to `lib.rs`: `pub use memex::{Memex, StorageHealth};`
- [ ] sherlock-holmes subagent verification COMPLETE

---

## NO BACKWARDS COMPATIBILITY

- Do NOT create mock implementations
- Do NOT add fallbacks for missing methods
- Do NOT use `async` or `async_trait` (codebase is synchronous)
- If something fails, it MUST error with descriptive `StorageError`
- Tests MUST use real RocksDB instances via `tempfile::TempDir`

---

## FINAL VERIFICATION: sherlock-holmes Subagent

After completing implementation, spawn `sherlock-holmes` subagent to verify:
1. All trait methods are implemented
2. All tests pass with real data
3. Object safety verified
4. No clippy warnings
5. Re-exports correct in lib.rs
6. StorageHealth contains actual metrics from RocksDB

The sherlock-holmes agent MUST report "CASE CLOSED: All evidence confirms task completion" before marking this task complete.

---

*Task ID: TASK-M02-026*
*Module: 02 - Core Infrastructure*
*Layer: Surface*
*Updated: 2025-12-31*
