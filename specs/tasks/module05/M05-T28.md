# M05-T28: Implement CognitivePulse Header for MCP Responses

```yaml
metadata:
  id: "M05-T28"
  title: "Implement CognitivePulse Header for MCP Responses"
  module: "module-05"
  module_name: "UTL Integration"
  layer: "integration"
  priority: "high"
  estimated_hours: 3
  created: "2026-01-04"
  updated: "2026-01-04"
  status: "pending"
  dependencies:
    - "M05-T22"  # UtlProcessor Main Orchestrator - COMPLETED
    - "M05-T24"  # Metrics Module with UtlStatus - COMPLETED
    - "M05-T26"  # utl_status MCP Tool - COMPLETED
  spec_refs:
    - "SPEC-UTL-005 Section 10.3"
    - "constitution.yaml:152-163"
```

---

## Current Codebase State (Audited 2026-01-04)

### Existing Files (DO NOT CREATE - EDIT THESE)

| File | Purpose | Current State |
|------|---------|---------------|
| `crates/context-graph-mcp/src/server.rs` | MCP server entry | Uses `StubUtlProcessor` (line 27) |
| `crates/context-graph-mcp/src/handlers/tools.rs` | Tool implementations | `call_get_memetic_status` at line 199 |
| `crates/context-graph-mcp/src/tools.rs` | Tool definitions | 6 tools defined, lines 43-184 |
| `crates/context-graph-mcp/src/handlers/mod.rs` | Handler module | Contains `Handlers` struct |

### Files to Create

| File | Purpose |
|------|---------|
| `crates/context-graph-mcp/src/middleware/mod.rs` | Middleware module |
| `crates/context-graph-mcp/src/middleware/cognitive_pulse.rs` | CognitivePulse implementation |
| `crates/context-graph-mcp/tests/cognitive_pulse_tests.rs` | Integration tests |

### Key Interfaces (Source of Truth)

**UtlProcessor Trait** (`crates/context-graph-core/src/traits/utl_processor.rs:40-79`):
```rust
#[async_trait]
pub trait UtlProcessor: Send + Sync {
    async fn compute_learning_score(&self, input: &str, context: &UtlContext) -> CoreResult<f32>;
    async fn compute_surprise(&self, input: &str, context: &UtlContext) -> CoreResult<f32>;
    async fn compute_coherence_change(&self, input: &str, context: &UtlContext) -> CoreResult<f32>;
    async fn compute_emotional_weight(&self, input: &str, context: &UtlContext) -> CoreResult<f32>;
    async fn compute_alignment(&self, input: &str, context: &UtlContext) -> CoreResult<f32>;
    async fn should_consolidate(&self, node: &MemoryNode) -> CoreResult<bool>;
    async fn compute_metrics(&self, input: &str, context: &UtlContext) -> CoreResult<UtlMetrics>;
    fn get_status(&self) -> serde_json::Value;  // Returns UtlStatusResponse-compatible JSON
}
```

**UtlStatusResponse** (`crates/context-graph-utl/src/metrics.rs:524-551`):
```rust
pub struct UtlStatusResponse {
    pub lifecycle_phase: String,       // "Infancy" | "Growth" | "Maturity"
    pub interaction_count: u64,
    pub entropy: f32,                  // [0.0, 1.0]
    pub coherence: f32,                // [0.0, 1.0]
    pub learning_score: f32,           // [0.0, 1.0]
    pub johari_quadrant: String,       // "Open" | "Blind" | "Hidden" | "Unknown"
    pub consolidation_phase: String,   // "Wake" | "NREM" | "REM"
    pub phase_angle: f32,
    pub thresholds: ThresholdsResponse,
}
```

**StubUtlProcessor** (`crates/context-graph-core/src/stubs/utl_stub.rs:15-123`):
- Returns hardcoded defaults in `get_status()` (lines 104-122)
- Hash-based deterministic computation for metrics

---

## Description

Implement CognitivePulse struct for inclusion in every MCP response:
- Fields: entropy (f32), coherence (f32), learning_score (f32), quadrant (String), suggested_action (String)
- Create MCP middleware to inject CognitivePulse into ALL tool responses
- Performance impact MUST be < 1ms per response (FAIL if exceeded)
- NO fallback to defaults - system MUST work with real UTL processor or fail fast

---

## Critical Requirements

### NO BACKWARDS COMPATIBILITY - FAIL FAST
- System works or fails completely with robust error logging
- No graceful degradation to default values
- No optional pulse fields - all fields required
- Log errors with full context and fail the request

### NO MOCK DATA IN TESTS
- All tests use real `UtlProcessor` from `context-graph-utl`
- Test against actual metrics computation
- No `StubUtlProcessor` in integration tests

### NO WORKAROUNDS OR FALLBACKS
- If UTL processor unavailable → error response, not default pulse
- If computation exceeds 1ms → log warning but continue (don't fail)
- If validation fails → error response with details

---

## Acceptance Criteria

- [ ] CognitivePulse struct with 5 required fields (no Option types)
- [ ] Every MCP tool response includes `_cognitive_pulse` field
- [ ] Middleware computes live UTL state from real processor
- [ ] Performance < 1ms per pulse computation
- [ ] All tests use real UtlProcessor (no stubs)
- [ ] JSON schema documented
- [ ] Error responses for all failure modes

---

## Implementation

### 1. CognitivePulse Struct

```rust
// crates/context-graph-mcp/src/middleware/cognitive_pulse.rs

use serde::{Deserialize, Serialize};
use std::sync::Arc;
use std::time::Instant;
use tracing::{debug, error, warn};

use context_graph_core::traits::UtlProcessor;

/// CognitivePulse provides real-time UTL state in every MCP response.
///
/// All fields are REQUIRED - no Option types.
/// Computation MUST complete in < 1ms.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CognitivePulse {
    /// Current entropy (surprise) level in [0.0, 1.0]
    pub entropy: f32,

    /// Current coherence level in [0.0, 1.0]
    pub coherence: f32,

    /// Current learning magnitude in [0.0, 1.0]
    pub learning_score: f32,

    /// Johari quadrant: "Open" | "Blind" | "Hidden" | "Unknown"
    pub quadrant: String,

    /// Suggested action per constitution.yaml:159-163
    /// Maps: Open→DirectRecall, Blind→TriggerDream, Hidden→GetNeighborhood, Unknown→EpistemicAction
    pub suggested_action: String,
}

/// Error type for pulse computation failures.
#[derive(Debug, thiserror::Error)]
pub enum PulseError {
    #[error("UTL processor unavailable")]
    ProcessorUnavailable,

    #[error("Invalid pulse values: {0}")]
    ValidationFailed(String),

    #[error("Computation failed: {0}")]
    ComputationFailed(String),
}

impl CognitivePulse {
    /// Create pulse from UTL processor state.
    ///
    /// # Errors
    /// Returns error if processor is unavailable or values are invalid.
    pub fn from_processor(processor: &dyn UtlProcessor) -> Result<Self, PulseError> {
        let start = Instant::now();

        let status = processor.get_status();

        let entropy = status.get("entropy")
            .and_then(|v| v.as_f64())
            .map(|v| v as f32)
            .ok_or_else(|| PulseError::ComputationFailed("missing entropy".into()))?;

        let coherence = status.get("coherence")
            .and_then(|v| v.as_f64())
            .map(|v| v as f32)
            .ok_or_else(|| PulseError::ComputationFailed("missing coherence".into()))?;

        let learning_score = status.get("learning_score")
            .and_then(|v| v.as_f64())
            .map(|v| v as f32)
            .ok_or_else(|| PulseError::ComputationFailed("missing learning_score".into()))?;

        let quadrant = status.get("johari_quadrant")
            .and_then(|v| v.as_str())
            .ok_or_else(|| PulseError::ComputationFailed("missing johari_quadrant".into()))?
            .to_string();

        // Map Johari quadrant to suggested action (constitution.yaml:159-163)
        let suggested_action = match quadrant.as_str() {
            "Open" => "DirectRecall",
            "Blind" => "TriggerDream",
            "Hidden" => "GetNeighborhood",
            "Unknown" => "EpistemicAction",
            _ => {
                error!("Invalid Johari quadrant: {}", quadrant);
                return Err(PulseError::ValidationFailed(format!(
                    "invalid quadrant: {}", quadrant
                )));
            }
        }.to_string();

        let pulse = Self {
            entropy,
            coherence,
            learning_score,
            quadrant,
            suggested_action,
        };

        // Validate ranges
        pulse.validate()?;

        let elapsed = start.elapsed();
        if elapsed.as_micros() > 1000 {
            warn!(
                elapsed_us = elapsed.as_micros(),
                "CognitivePulse computation exceeded 1ms target"
            );
        }
        debug!(
            elapsed_us = elapsed.as_micros(),
            entropy = pulse.entropy,
            coherence = pulse.coherence,
            quadrant = pulse.quadrant,
            "CognitivePulse computed"
        );

        Ok(pulse)
    }

    /// Validate pulse values are within expected ranges.
    fn validate(&self) -> Result<(), PulseError> {
        if !(0.0..=1.0).contains(&self.entropy) {
            return Err(PulseError::ValidationFailed(format!(
                "entropy {} not in [0.0, 1.0]", self.entropy
            )));
        }
        if !(0.0..=1.0).contains(&self.coherence) {
            return Err(PulseError::ValidationFailed(format!(
                "coherence {} not in [0.0, 1.0]", self.coherence
            )));
        }
        if !(0.0..=1.0).contains(&self.learning_score) {
            return Err(PulseError::ValidationFailed(format!(
                "learning_score {} not in [0.0, 1.0]", self.learning_score
            )));
        }

        let valid_quadrants = ["Open", "Blind", "Hidden", "Unknown"];
        if !valid_quadrants.contains(&self.quadrant.as_str()) {
            return Err(PulseError::ValidationFailed(format!(
                "quadrant {} not in {:?}", self.quadrant, valid_quadrants
            )));
        }

        Ok(())
    }
}
```

### 2. Middleware Implementation

```rust
// crates/context-graph-mcp/src/middleware/mod.rs

mod cognitive_pulse;

pub use cognitive_pulse::{CognitivePulse, PulseError};
```

### 3. Integrate with Tool Responses

Modify `crates/context-graph-mcp/src/handlers/tools.rs`:

```rust
// Add to tool_result helper (line 83-97)
pub(super) fn tool_result_with_pulse(
    id: Option<JsonRpcId>,
    data: serde_json::Value,
    pulse: CognitivePulse,
) -> JsonRpcResponse {
    let mut response_data = serde_json::json!({
        "content": [{
            "type": "text",
            "text": serde_json::to_string(&data).unwrap_or_else(|_| "{}".to_string())
        }],
        "isError": false,
        "_cognitive_pulse": pulse
    });

    JsonRpcResponse::success(id, response_data)
}

// Update each tool call to include pulse:
// Example for call_get_memetic_status (line 199-270):
pub(super) async fn call_get_memetic_status(&self, id: Option<JsonRpcId>) -> JsonRpcResponse {
    // Compute pulse first - fail fast if unavailable
    let pulse = match CognitivePulse::from_processor(self.utl_processor.as_ref()) {
        Ok(p) => p,
        Err(e) => {
            error!("CognitivePulse computation failed: {}", e);
            return Self::tool_error(id, &format!("UTL processing failed: {}", e));
        }
    };

    // ... rest of implementation ...

    Self::tool_result_with_pulse(id, json!({...}), pulse)
}
```

---

## Test Cases (Real Data Only)

```rust
// crates/context-graph-mcp/tests/cognitive_pulse_tests.rs

use context_graph_mcp::middleware::{CognitivePulse, PulseError};
use context_graph_utl::UtlProcessor;
use context_graph_utl::config::UtlConfig;
use std::sync::Arc;
use std::time::Instant;

/// TC-M05-T28-001: CognitivePulse computation with real processor
#[test]
fn test_cognitive_pulse_from_real_processor() {
    let processor = UtlProcessor::new(UtlConfig::default());

    let pulse = CognitivePulse::from_processor(&processor)
        .expect("pulse computation should succeed");

    // Verify all fields present and valid
    assert!((0.0..=1.0).contains(&pulse.entropy));
    assert!((0.0..=1.0).contains(&pulse.coherence));
    assert!((0.0..=1.0).contains(&pulse.learning_score));
    assert!(["Open", "Blind", "Hidden", "Unknown"].contains(&pulse.quadrant.as_str()));
    assert!(!pulse.suggested_action.is_empty());
}

/// TC-M05-T28-002: Johari quadrant to action mapping (constitution.yaml:159-163)
#[test]
fn test_johari_quadrant_action_mapping() {
    // This test verifies constitution.yaml:159-163 mapping
    let mappings = [
        ("Open", "DirectRecall"),
        ("Blind", "TriggerDream"),
        ("Hidden", "GetNeighborhood"),
        ("Unknown", "EpistemicAction"),
    ];

    // Create processor and manipulate state for each quadrant test
    for (quadrant, expected_action) in mappings {
        // NOTE: Real implementation needs to trigger each quadrant state
        // This is a schema validation test
        let pulse = CognitivePulse {
            entropy: 0.5,
            coherence: 0.5,
            learning_score: 0.5,
            quadrant: quadrant.to_string(),
            suggested_action: expected_action.to_string(),
        };
        assert_eq!(pulse.suggested_action, expected_action);
    }
}

/// TC-M05-T28-003: Performance < 1ms
#[test]
fn test_cognitive_pulse_performance() {
    let processor = UtlProcessor::new(UtlConfig::default());

    // Warm up
    for _ in 0..10 {
        let _ = CognitivePulse::from_processor(&processor);
    }

    // Measure 1000 iterations
    let start = Instant::now();
    for _ in 0..1000 {
        let _ = CognitivePulse::from_processor(&processor);
    }
    let elapsed = start.elapsed();

    let avg_us = elapsed.as_micros() / 1000;
    assert!(
        avg_us < 1000,
        "Average pulse computation {}us exceeds 1ms (1000us) target",
        avg_us
    );
}

/// TC-M05-T28-004: Validation rejects out-of-range values
#[test]
fn test_cognitive_pulse_validation_rejects_invalid() {
    // Entropy > 1.0
    let invalid = CognitivePulse {
        entropy: 1.5,
        coherence: 0.5,
        learning_score: 0.5,
        quadrant: "Open".to_string(),
        suggested_action: "DirectRecall".to_string(),
    };
    assert!(invalid.validate().is_err());

    // Invalid quadrant
    let invalid = CognitivePulse {
        entropy: 0.5,
        coherence: 0.5,
        learning_score: 0.5,
        quadrant: "InvalidQuadrant".to_string(),
        suggested_action: "DirectRecall".to_string(),
    };
    assert!(invalid.validate().is_err());
}

/// TC-M05-T28-005: All MCP tool responses include pulse
#[tokio::test]
async fn test_all_tools_include_cognitive_pulse() {
    let server = create_test_mcp_server_with_real_utl().await;

    let tools = vec![
        ("inject_context", json!({"content": "test", "rationale": "testing"})),
        ("store_memory", json!({"content": "test"})),
        ("get_memetic_status", json!({})),
        ("get_graph_manifest", json!({})),
        ("search_graph", json!({"query": "test"})),
        ("utl_status", json!({})),
    ];

    for (tool_name, args) in tools {
        let response = server.call_tool(tool_name, args).await.unwrap();

        let pulse = response.get("_cognitive_pulse");
        assert!(
            pulse.is_some(),
            "Tool '{}' missing _cognitive_pulse in response",
            tool_name
        );

        let pulse = pulse.unwrap();
        assert!(pulse.get("entropy").is_some(), "{} missing entropy", tool_name);
        assert!(pulse.get("coherence").is_some(), "{} missing coherence", tool_name);
        assert!(pulse.get("learning_score").is_some(), "{} missing learning_score", tool_name);
        assert!(pulse.get("quadrant").is_some(), "{} missing quadrant", tool_name);
        assert!(pulse.get("suggested_action").is_some(), "{} missing suggested_action", tool_name);
    }
}

/// TC-M05-T28-006: Serialization round-trip
#[test]
fn test_cognitive_pulse_serialization() {
    let pulse = CognitivePulse {
        entropy: 0.42,
        coherence: 0.78,
        learning_score: 0.55,
        quadrant: "Open".to_string(),
        suggested_action: "DirectRecall".to_string(),
    };

    let json = serde_json::to_string(&pulse).expect("serialize");
    assert!(json.contains("\"entropy\":0.42"));
    assert!(json.contains("\"quadrant\":\"Open\""));

    let deserialized: CognitivePulse = serde_json::from_str(&json).expect("deserialize");
    assert!((deserialized.entropy - 0.42).abs() < 0.001);
    assert_eq!(deserialized.quadrant, "Open");
}
```

---

## Full State Verification Protocol

### Source of Truth

| Component | File:Line | Description |
|-----------|-----------|-------------|
| UtlProcessor trait | `crates/context-graph-core/src/traits/utl_processor.rs:40-79` | Interface contract |
| get_status() return | `crates/context-graph-utl/src/metrics.rs:524-551` | UtlStatusResponse schema |
| Johari→Action map | `docs/constitution.yaml:159-163` | Quadrant action mapping |
| StubUtlProcessor | `crates/context-graph-core/src/stubs/utl_stub.rs:104-122` | Default status JSON |
| MCP tool response | `crates/context-graph-mcp/src/handlers/tools.rs:83-97` | tool_result format |

### Edge Cases (3 Required)

1. **Empty/Initial State**: Processor with 0 interactions returns valid pulse with default values
   - Expected: entropy=0.0, coherence=0.0, quadrant="Hidden", action="GetNeighborhood"

2. **Lifecycle Transition**: Processor at Infancy→Growth threshold (50 interactions)
   - Expected: Phase changes, thresholds update, pulse reflects new stage

3. **Concurrent Access**: 100 simultaneous pulse computations
   - Expected: All complete < 1ms, no race conditions, consistent values

### Evidence of Success

```bash
# Run all pulse tests
cargo test --package context-graph-mcp cognitive_pulse -- --nocapture

# Run performance benchmark
cargo bench --package context-graph-mcp pulse_perf

# Verify integration
cargo test --package context-graph-mcp all_tools_include_cognitive_pulse

# Expected output:
# - 6 tests passed
# - Average pulse computation < 500us
# - All tool responses contain _cognitive_pulse field
```

---

## Verification Commands

```bash
# Build and test
cargo build --package context-graph-mcp
cargo test --package context-graph-mcp --lib
cargo test --package context-graph-mcp --test cognitive_pulse_tests

# Verify no stub usage in tests
grep -r "StubUtlProcessor" crates/context-graph-mcp/tests/ && echo "ERROR: Stubs found in tests" || echo "OK: No stubs"

# Verify all tools include pulse
cargo test all_tools_include_cognitive_pulse -- --nocapture
```

---

## Final Verification (REQUIRED)

After implementation, run sherlock-holmes subagent:

```
Task(sherlock-holmes): Forensic verification of M05-T28 CognitivePulse implementation.
Verify:
1. CognitivePulse struct at crates/context-graph-mcp/src/middleware/cognitive_pulse.rs
2. All 5 fields present, no Option types
3. Johari→action mapping matches constitution.yaml:159-163
4. Performance < 1ms verified via benchmark
5. All 6 MCP tools include _cognitive_pulse in response
6. No StubUtlProcessor usage in tests
7. Error logging for all failure paths
```

---

## Git History Context

Recent commits (as of 2026-01-04):
- `6d7e230` M05-T26: utl_status MCP tool implemented
- `5a4074f` M05-T25: Integration tests complete
- `6e4b6d3` M05-T24: Metrics module with UtlStatus
- `781f0ac` M05-T22: UtlProcessor orchestrator complete

This task builds on the completed UTL infrastructure to add pulse headers.
